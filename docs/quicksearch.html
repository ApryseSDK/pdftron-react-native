<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_src_DocumentView_DocumentView.js.html":{"id":"lib_src_DocumentView_DocumentView.js.html","title":"Source: lib/src/DocumentView/DocumentView.js","body":" PDFTron React Native Classes ConfigDocumentViewPDFViewCtrlRNPdftron Events onAnnotationMenuPressonAnnotationsSelectedonAnnotationChangedonFormFieldValueChangedonBookmarkChangedonBehaviorActivatedonExportAnnotationCommandonLayoutChangedonLongPressMenuPressonTabChangedonDocumentLoadedonDocumentErroronPageChangedonPageMovedonScrollChangedonTextSearchStartonTextSearchResultonLeadingNavButtonPressedonToolChangedonUndoRedoStateChangedonZoomChangedonZoomFinished Source: lib/src/DocumentView/DocumentView.js import React, { PureComponent } from 'react'; import PropTypes from 'prop-types'; import { requireNativeComponent, ViewPropTypes, Platform, Alert, NativeModules, findNodeHandle } from 'react-native'; import { Config } from \"../Config/Config\"; const { DocumentViewManager } = NativeModules; /** * @desc This object outlines valid {@link DocumentView} class props. * These can be passed into {@link DocumentView} to customize the viewer. * * For Contributors: The propTypes interface below contains PropTypes types for * the {@link DocumentView} class. * It is also used to generate custom types for TS users. * * To represent functions, please use {@link func}. * To represent \"one of Config.Buttons values\" or \"an array of * Config.Buttons values\", please use {@link oneOf} or {@link arrayOf}. * * @ignore */ export const DocumentViewPropTypes = { /** * @memberof DocumentView * @category Open a Document * @type {string} * @desc The path or url to the document. Required. * @example * &lt;DocumentView * document={'https://pdftron.s3.amazonaws.com/downloads/pl/PDFTRON_about.pdf'} * /&gt; */ document: PropTypes.string.isRequired, /** * @memberof DocumentView * @category Open a Document * @type {string} * @optional * @desc The password of the document, if any. * @example * &lt;DocumentView * password={'password'} * /&gt; */ password: PropTypes.string, /** * @memberof DocumentView * @category Page * @type {number} * @optional * @desc Defines the initial page number that viewer displays when the document is opened. * Note that page numbers are 1-indexed. * @example * &lt;DocumentView * initialPageNumber={5} * /&gt; */ initialPageNumber: PropTypes.number, /** * @memberof DocumentView * @category Page * @type {number} * @optional * @desc Defines the currently displayed page number. * Different from {@link DocumentView.initialPageNumber initialPageNumber}, * changing this prop value at runtime will change the page accordingly. * @example * &lt;DocumentView * pageNumber={5} * /&gt; */ pageNumber: PropTypes.number, /** * @memberof DocumentView * @category Open a Document * @type {object} * @optional * @desc Defines custom headers to use with HTTP/HTTPS requests. * @example * &lt;DocumentView * customHeaders={{headerKey: 'headerValue'}} * /&gt; */ customHeaders: PropTypes.object, /** * @memberof DocumentView * @category UI Customization * @type {string} * @optional * @desc The file name of the icon to be used for the leading navigation button. * The button will use the specified icon if it is valid, and the default icon otherwise. * * **Note**: to add the image file to your application, please follow the steps below: * * ##### Android * 1. Add the image resource to the drawable directory in * [`example/android/app/src/main/res`](https://github.com/PDFTron/pdftron-react-native/blob/master/example/android/app/src/main/res). * For details about supported file types and potential compression, check out * [here](https://developer.android.com/guide/topics/graphics/drawables#drawables-from-images). * * &lt;img alt='demo-android' src='https://pdftron.s3.amazonaws.com/custom/websitefiles/react-native/android_add_resources.png'/&gt; * &lt;br/&gt;&lt;br/&gt; * 2. Now you can use the image in the viewer. * For example, if you add `button_close.png` to drawable, * you could use `'button_close'` in leadingNavButtonIcon. * * ##### iOS * 1. After pods has been installed, open the `.xcworkspace` file for this application in Xcode * (in this case, it's [`example.xcworkspace`](https://github.com/PDFTron/pdftron-react-native/tree/master/example/ios/example.xcworkspace)), * and navigate through the list below. * This would allow you to add resources, in this case, an image, to your project. * - \"Project navigator\" * - \"example\" (or the app name) * - \"Build Phases\" * - \"Copy Bundle Resources\" * - \"+\". * * &lt;img alt='demo-ios' src='https://pdftron.s3.amazonaws.com/custom/websitefiles/react-native/ios_add_resources.png'/&gt; * &lt;br/&gt;&lt;br/&gt; * 2. Now you can use the image in the viewer. * For example, if you add `button_open.png` to the bundle, * you could use `'button_open.png'` in leadingNavButtonIcon. * * @example * let iosNav = 'ic_close_black_24px.png'; * let androidNav = 'ic_arrow_back_white_24dp'; * &lt;DocumentView * leadingNavButtonIcon={Platform.OS === 'ios' ? iosNav : androidNav} * /&gt; */ leadingNavButtonIcon: PropTypes.string, /** * @memberof DocumentView * @category UI Customization * @type {boolean} * @optional * @default true * @desc Defines whether to show the leading navigation button. * @example * &lt;DocumentView * showLeadingNavButton={true} * /&gt; */ showLeadingNavButton: PropTypes.bool, /** * @memberof DocumentView * @category UI Customization * @event * @type {function} * @optional * @desc This function is called when the leading navigation button is pressed. * @example * &lt;DocumentView * onLeadingNavButtonPressed = {() =&gt; { * console.log('The leading nav has been pressed'); * }} * /&gt; */ onLeadingNavButtonPressed: func(), /** * @memberof DocumentView * @category Open a Document * @event * @type {function} * @optional * @desc This function is called when the document finishes loading. * @param {string} path * @example * &lt;DocumentView * onDocumentLoaded = {(path) =&gt; { * console.log('The document has finished loading:', path); * }} * /&gt; */ onDocumentLoaded: func(), /** * @memberof DocumentView * @category Open a Document * @event * @type {function} * @optional * @desc This function is called when document opening encounters an error. * @param {string} error * @example * &lt;DocumentView * onDocumentError = {(error) =&gt; { * console.log('Error occured during document opening:', error); * }} * /&gt; */ onDocumentError: func(), /** * @memberof DocumentView * @category Page * @event * @type {function} * @optional * @desc This function is called when the page number has been changed. * @param {int} previousPageNumber the previous page number * @param {int} pageNumber the current page number * @example * &lt;DocumentView * onPageChanged = {({previousPageNumber, pageNumber}) =&gt; { * console.log('Page number changes from', previousPageNumber, 'to', pageNumber); * }} * /&gt; */ onPageChanged: func(), /** * @memberof DocumentView * @category Scroll * @event * @type {function} * @optional * @desc This function is called when the scroll position has been changed. * @param {number} horizontal the horizontal position of the scroll * @param {number} vertical the vertical position of the scroll * @example * &lt;DocumentView * onScrollChanged = {({horizontal, vertical}) =&gt; { * console.log('Current scroll position is', horizontal, * 'horizontally, and', vertical, 'vertically.'); * }} * /&gt; */ onScrollChanged: func(), /** * @memberof DocumentView * @category Zoom * @event * @type {function} * @optional * @desc This function is called when the zoom scale has been changed. * @param {double} zoom the current zoom ratio of the document * @example * &lt;DocumentView * onZoomChanged = {(zoom) =&gt; { * console.log('Current zoom ratio is', zoom); * }} * /&gt; */ onZoomChanged: func(), /** * @memberof DocumentView * @category Zoom * @event * @type {function} * @optional * @desc This function is called when a zooming has been finished. * For example, if zoom via gesture, this is called on gesture release. * @param {double} zoom the current zoom ratio of the document * @example * &lt;DocumentView * onZoomFinished = {(zoom) =&gt; { * console.log('Current zoom ratio is', zoom); * }} * /&gt; */ onZoomFinished: func(), /** * @memberof DocumentView * @category Zoom * @type {number} * @optional * @desc Zoom factor used to display the page content. * @example * &lt;DocumentView * zoom={1} * /&gt; */ zoom: PropTypes.number, /** * @memberof DocumentView * @category UI Customization * @type {Config.Buttons[]} * @optional * @default Defaults to none. * @desc Defines buttons to be disabled for the viewer. * @example * &lt;DocumentView * disabledElements={[Config.Buttons.userBookmarkListButton]} * /&gt; */ disabledElements: arrayOf(Config.Buttons), /** * @memberof DocumentView * @category UI Customization * @type {Config.Tools[]} * @optional * @default Defaults to none. * @desc Defines tools to be disabled for the viewer. * @example * &lt;DocumentView * disabledTools={[Config.Tools.annotationCreateLine, Config.Tools.annotationCreateRectangle]} * /&gt; */ disabledTools: arrayOf(Config.Tools), /** * @memberof DocumentView * @category Long Press Menu * @type {Config.LongPressMenu[]} * @optional * @default Contains all the items. * @desc Defines menu items that can show when long press on text or blank space. * @example * &lt;DocumentView * longPressMenuItems={[Config.LongPressMenu.copy, Config.LongPressMenu.read]} * /&gt; */ longPressMenuItems: arrayOf(Config.LongPressMenu), /** * @memberof DocumentView * @category Long Press Menu * @type {Config.LongPressMenu[]} * @optional * @default Defaults to none. * @desc Defines the menu items on long press that will skip default behavior when pressed. * They will still be displayed in the long press menu, * and the function {@link DocumentView.event:onLongPressMenuPress onLongPressMenuPress} * will be called where custom behavior can be implemented. * @example * &lt;DocumentView * overrideLongPressMenuBehavior={[Config.LongPressMenu.search]} * /&gt; */ overrideLongPressMenuBehavior: arrayOf(Config.LongPressMenu), /** * @memberof DocumentView * @category Long Press Menu * @event * @type {function} * @optional * @desc This function is called if the pressed long press menu item is passed in to * {@link DocumentView.overrideLongPressMenuBehavior overrideLongPressMenuBehavior}. * @param {Config.LongPressMenu} longPressMenu the menu item that has been pressed. * @param {string} longPressText the selected text if pressed on text, empty otherwise * @example * &lt;DocumentView * onLongPressMenuPress = {({longPressMenu, longPressText}) =&gt; { * console.log('Long press menu item', longPressMenu, 'has been pressed'); * if (longPressText !== '') { * console.log('The selected text is', longPressText); * } * }} * /&gt; */ onLongPressMenuPress: func(), /** * @memberof DocumentView * @category Long Press Menu * @type {boolean} * @optional * @default true * @desc Defines whether to show the popup menu of options * when the user long presses on text or blank space on the document. * @example * &lt;DocumentView * longPressMenuEnabled={true} * /&gt; */ longPressMenuEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Annotation Menu * @type {Config.AnnotationMenu[]} * @optional * @default Contains all the items. * @desc Defines the menu items that can show when an annotation is selected. * @example * &lt;DocumentView * annotationMenuItems={[Config.AnnotationMenu.search, Config.AnnotationMenu.share]} * /&gt; */ annotationMenuItems: arrayOf(Config.AnnotationMenu), /** * @memberof DocumentView * @category Annotation Menu * @type {Config.AnnotationMenu[]} * @optional * @default Defaults to none. * @desc Defines the menu items that will skip default behavior when pressed. * They will still be displayed in the annotation menu, * and the function {@link DocumentView.event:onAnnotationMenuPress onAnnotationMenuPress} * will be called where custom behavior can be implemented. * @example * &lt;DocumentView * overrideAnnotationMenuBehavior={[Config.AnnotationMenu.copy]} * /&gt; */ overrideAnnotationMenuBehavior: arrayOf(Config.AnnotationMenu), /** * @memberof DocumentView * @category Annotation Menu * @event * @type {function} * @optional * @desc This function is called when an annotation menu item passed in to * {@link DocumentView.overrideAnnotationMenuBehavior overrideAnnotationMenuBehavior} is pressed. * @param {Config.AnnotationMenu} annotationMenu the menu item that has been pressed. * @param {object[]} annotations An array of * `{id: string, pageNumber: number, type: string, screenRect: object, pageRect: object}` objects. * * `id` is the annotation identifier and `type` is one of the {@link Config.Tools} constants. * * `screenRect` was formerly called `rect`. * * Both rects are represented with * `{x1: number, y1: number, x2: number, y2: number, width: number, height: number}` objects. * @example * &lt;DocumentView * onAnnotationMenuPress = {({annotationMenu, annotations}) =&gt; { * console.log('Annotation menu item', annotationMenu, 'has been pressed'); * annotations.forEach(annotation =&gt; { * console.log('The id of selected annotation is', annotation.id); * console.log('The page number of selected annotation is', annotation.pageNumber); * console.log('The type of selected annotation is', annotation.type); * console.log('The screenRect of selected annotation is', annotation.screenRect); * console.log('The pageRect of selected annotation is', annotation.pageRect); * }); * }} * /&gt; */ onAnnotationMenuPress: func(), /** * @memberof DocumentView * @category Annotation Menu * @type {Config.Tools[]} * @optional * @default Defaults to none. * @desc Defines annotation types that will not show in the annotation (long-press) menu. * @example * &lt;DocumentView * hideAnnotationMenu={[Config.Tools.annotationCreateArrow, Config.Tools.annotationEraserTool]} * /&gt; */ hideAnnotationMenu: arrayOf(Config.Tools), /** * @memberof DocumentView * @category Custom Behavior * @type {Config.Actions[]} * @optional * @default Defaults to none. * @desc Defines actions that will skip default behavior, such as external link click. * The function {@link DocumentView.event:onBehaviorActivated onBehaviorActivated} will be * called where custom behavior can be implemented, whenever the defined actions occur. * @example * &lt;DocumentView * overrideBehavior={[Config.Actions.linkPress]} * /&gt; */ overrideBehavior: arrayOf(Config.Actions), /** * @memberof DocumentView * @category Custom Behavior * @event * @type {function} * @optional * @desc This function is called if the activated behavior is passed in to * {@link DocumentView.overrideBehavior overrideBehavior} * @param {Config.Actions} action the action which has been activated. * @param {object} data A JSON object that varies depending on the action. * * If action is `Config.Actions.linkPress`, data type is `{url: string}`. * * If action is `Config.Actions.stickyNoteShowPopUp`, data type is * `{id: string, pageNumber: number, type: string, * screenRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}, * pageRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}}` * * `type` is one of the {@link Config.Tools} constants, * * `screenRect` was formerly called `rect`. * @example * &lt;DocumentView * onBehaviorActivated = {({action, data}) =&gt; { * console.log('Activated action is', action); * if (action === Config.Actions.linkPress) { * console.log('The external link pressed is', data.url); * } else if (action === Config.Actions.stickyNoteShowPopUp) { * console.log('Sticky note has been activated, but it would not show a pop up window.'); * } * }} * /&gt; */ onBehaviorActivated: func(), /** * @memberof DocumentView * @category Toolbar Customization * @type {boolean} * @optional * @default true * @deprecated Use the {@link DocumentView.hideTopAppNavBar hideTopAppNavBar} prop instead. */ topToolbarEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Toolbar Customization * @type {boolean} * @optional * @default true * @desc Defines whether the bottom toolbar of the viewer is enabled. * @example * &lt;DocumentView * bottomToolbarEnabled={false} * /&gt; */ bottomToolbarEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Toolbar Customization * @type {boolean} * @optional * @default true * @desc Defines whether an unhandled tap in the viewer should toggle the visibility * of the top and bottom toolbars. When false, the top and bottom toolbar visibility * will not be toggled and the page content will fit between the bars, if any. * @example * &lt;DocumentView * hideToolbarsOnTap={false} * /&gt; */ hideToolbarsOnTap: PropTypes.bool, /** * @memberof DocumentView * @category UI Customization * @type {boolean} * @optional * @default true * @desc Defines whether the document slider of the viewer is enabled. * @example * &lt;DocumentView * documentSliderEnabled={false} * /&gt; */ documentSliderEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Page * @type {boolean} * @optional * @default true * @desc Defines whether to show the page indicator for the viewer. * @example * &lt;DocumentView * pageIndicatorEnabled={true} * /&gt; */ pageIndicatorEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Page * @type {boolean} * @optional * @default true * @desc iOS only * * Defines whether the keyboard shortcuts of the viewer are enabled. * @example * &lt;DocumentView * keyboardShortcutsEnabled={false} * /&gt; */ keyboardShortcutsEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Annotations * @event * @type {function} * @optional * @desc This function is called when an annotation(s) is selected. * @param {object[]} annotations array of annotation data in the format * `{id: string, pageNumber: number, type: string, * screenRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}, * pageRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}}`, * representing the selected annotations. * * `type` is one of the {@link Config.Tools} constants. * * `screenRect` was formerly called `rect`. * @example * &lt;DocumentView * onAnnotationsSelected = {({annotations}) =&gt; { * annotations.forEach(annotation =&gt; { * console.log('The id of selected annotation is', annotation.id); * console.log('It is in page', annotation.pageNumber); * console.log('Its type is', annotation.type); * }); * }} * /&gt; */ onAnnotationsSelected: func(), /** * @memberof DocumentView * @category Annotations * @event * @type {function} * @optional * @desc This function is called if a change has been made to an annotation(s) * in the current document. * @param {string} action the action that occurred (add, delete, modify) * @param {object[]} annotations array of annotation data in the format * `{id: string, pageNumber: number, type: string}`, * representing the annotations that have been changed. * * `type` is one of the {@link Config.Tools} constants * @example * &lt;DocumentView * onAnnotationChanged = {({action, annotations}) =&gt; { * console.log('Annotation edit action is', action); * annotations.forEach(annotation =&gt; { * console.log('The id of changed annotation is', annotation.id); * console.log('It is in page', annotation.pageNumber); * console.log('Its type is', annotation.type); * }); * }} * /&gt; */ onAnnotationChanged: func(), /** * @memberof DocumentView * @category Annotations * @event * @type {function} * @optional * @desc This function is called if a change has been made to form field values. * @param {object[]} fields array of field data in the format * `{fieldName: string, fieldType: string, fieldValue: any}`, * representing the fields that have been changed * @example * &lt;DocumentView * onFormFieldValueChanged = {({fields}) =&gt; { * fields.forEach(field =&gt; { * console.log('The name of the changed field is', field.fieldName); * console.log('The type of the changed field is', field.fieldType); * console.log('The value of the changed field is', field.fieldValue); * }); * }} * /&gt; */ onFormFieldValueChanged: func(), /** * @memberof DocumentView * @category Open a Document * @type {boolean} * @optional * @default false * @desc Defines whether the viewer is read-only. * If true, the UI will not allow the user to change the document. * @example * &lt;DocumentView * readOnly={true} * /&gt; */ readOnly: PropTypes.bool, /** * @memberof DocumentView * @category Thumbnails * @type {boolean} * @optional * @default true * @desc Defines whether user can modify the document * using the thumbnail view (eg add/remove/rotate pages). * @example * &lt;DocumentView * thumbnailViewEditingEnabled={true} * /&gt; */ thumbnailViewEditingEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Layout * @type {Config.FitMode} * @optional * @default Config.FitMode.FitWidth * @desc Defines the fit mode (default zoom level) of the viewer. * @example * &lt;DocumentView * fitMode={Config.FitMode.FitPage} * /&gt; */ fitMode: oneOf(Config.FitMode), /** * @memberof DocumentView * @category Layout * @type {Config.LayoutMode} * @optional * @default Config.LayoutMode.Continuous * @desc Defines the layout mode of the viewer. * @example * &lt;DocumentView * layoutMode={Config.LayoutMode.FacingContinuous} * /&gt; */ layoutMode: oneOf(Config.LayoutMode), /** * @memberof DocumentView * @category Layout * @event * @type {function} * @optional * @desc This function is called when the layout of the viewer has been changed. * @example * &lt;DocumentView * onLayoutChanged = {() =&gt; { * console.log('Layout has been updated.'); * }} * /&gt; */ onLayoutChanged: func(), /** * @memberof DocumentView * @category Toolbar Customization * @type {boolean} * @optional * @default false * @desc Android only * * Defines whether the viewer will add padding to take account of the system status bar. * @example * &lt;DocumentView * padStatusBar={true} * /&gt; */ padStatusBar: PropTypes.bool, /** * @memberof DocumentView * @category Annotations * @type {boolean} * @optional * @default true * @desc If true, the active annotation creation tool will remain in the current annotation * creation tool. Otherwise, it will revert to the \"pan tool\" after an annotation is created. * @example * &lt;DocumentView * continuousAnnotationEditing={true} * /&gt; */ continuousAnnotationEditing: PropTypes.bool, /** * @memberof DocumentView * @category Annotations * @type {boolean} * @optional * @default true * @desc Defines whether an annotation is selected after it is created. * On iOS, this functions for shape and text markup annotations only. * @example * &lt;DocumentView * selectAnnotationAfterCreation={true} * /&gt; */ selectAnnotationAfterCreation: PropTypes.bool, /** * @memberof DocumentView * @category Annotations * @type {string} * @optional * @desc Defines the author name for all annotations created on the current document. * Exported xfdfCommand will include this piece of information. * @example * &lt;DocumentView * annotationAuthor={'PDFTron'} * /&gt; */ annotationAuthor: PropTypes.string, /** * @memberof DocumentView * @category Signature * @type {boolean} * @optional * @default true * @desc Defines whether to show saved signatures for re-use when using the signing tool. * @example * &lt;DocumentView * showSavedSignatures={true} * /&gt; */ showSavedSignatures: PropTypes.bool, /** * @memberof DocumentView * @category Open a Document * @type {boolean} * @optional * @default false * @desc If true, {@link DocumentView.document document} prop will be treated as a base64 string. * If it is not the base64 string of a pdf file, * {@link DocumentView.base64FileExtension base64FileExtension} is required. * * When viewing a document initialized with a base64 string (i.e. a memory buffer), * a temporary file is created on Android and iOS. * @example * &lt;DocumentView * isBase64String={true} * document={'...'} // base 64 string * /&gt; */ isBase64String: PropTypes.bool, /** * @memberof DocumentView * @category Collaboration * @type {boolean} * @optional * @default false * @desc Defines whether to enable realtime collaboration. * If true then {@link DocumentView.currentUser currentUser} must be set as well for * collaboration mode to work. Feature set may vary between local and collaboration mode. * @example * &lt;DocumentView * collabEnabled={true} * currentUser={'Pdftron'} * /&gt; */ collabEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Collaboration * @type {string} * @desc Required if {@link DocumentView.collabEnabled collabEnabled} is set to true. * * Defines the current user. * Created annotations will have their title (author) set to this string. * @example * &lt;DocumentView * collabEnabled={true} * currentUser={'Pdftron'} * /&gt; */ currentUser: PropTypes.string, /** * @memberof DocumentView * @category Collaboration * @type {string} * @optional * @desc Defines the current user name. * Will set the user name only if {@link DocumentView.collabEnabled collabEnabled} is true * and {@link DocumentView.currentUser currentUser} is defined. This should be used only if * you want the user's display name to be different than the annotation's title/author * (in the case that {@link DocumentView.currentUser currentUser} is an ID rather than a * human-friendly name.) * @example * &lt;DocumentView * collabEnabled={true} * currentUser={'Pdftron'} * currentUserName={'Hello_World'} * /&gt; */ currentUserName: PropTypes.string, /** * @memberof DocumentView * @category Import/Export Annotations * @event * @type {function} * @optional * @desc This function is called if a change has been made to annotations in the current document. * Unlike {@link DocumentView.event:onAnnotationChanged onAnnotationChanged}, this function has * an XFDF command string as its parameter. If you are modifying or deleting multiple annotations, * then on Android the function is only called once, and on iOS it is called for each annotation. * * **Known Issues** * * On iOS, there is currently a bug that prevents the last XFDF from being retrieved when * modifying annotations while collaboration mode is enabled. * @param {string} action the action that occurred (add, delete, modify) * @param {string} xfdfCommand an xfdf string containing info about the edit * @param {array} annotations an array of annotation data. * When collaboration is enabled data comes in the format `{id: string}`, otherwise the format is * `{id: string, pageNumber: number, type: string}`. * In both cases, the data represents the annotations that have been changed. * * `type` is one of the {@link Config.Tools} constants. * @example * &lt;DocumentView * onExportAnnotationCommand = {({action, xfdfCommand, annotations}) =&gt; { * console.log('Annotation edit action is', action); * console.log('The exported xfdfCommand is', xfdfCommand); * annotations.forEach((annotation) =&gt; { * console.log('Annotation id is', annotation.id); * if (!this.state.collabEnabled) { * console.log('Annotation pageNumber is', annotation.pageNumber); * console.log('Annotation type is', annotation.type); * } * }); * }} * collabEnabled={this.state.collabEnabled} * currentUser={'Pdftron'} * /&gt; */ onExportAnnotationCommand: func(), /** * @memberof DocumentView * @type {boolean} * @optional * @default true * @desc Defines whether document is automatically saved by the viewer. * @example * &lt;DocumentView * autoSaveEnabled={true} * /&gt; */ autoSaveEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Page * @type {boolean} * @optional * @default true * @desc Defines whether the viewer should change pages when the user taps the edge of a page, * when the viewer is in a horizontal viewing mode. * @example * &lt;DocumentView * pageChangeOnTap={true} * /&gt; */ pageChangeOnTap: PropTypes.bool, /** * @memberof DocumentView * @type {boolean} * @optional * @default true * @desc Android and iOS 13+ only * * Defines whether the UI will appear in a dark color when the system is dark mode. * If false, it will use viewer setting instead. * @example * &lt;DocumentView * followSystemDarkMode={false} * /&gt; */ followSystemDarkMode: PropTypes.bool, /** * @memberof DocumentView * @type {boolean} * @optional * @default true * @desc Defines whether a stylus should act as a pen when in pan mode. * If false, it will act as a finger. * @example * &lt;DocumentView * useStylusAsPen={true} * /&gt; */ useStylusAsPen: PropTypes.bool, /** * @memberof DocumentView * @category Multi-tab * @type {boolean} * @optional * @default false * @desc Defines whether viewer will use tabs in order to have more than * one document open simultaneously (like a web browser). Changing the * {@link DocumentView.document document} prop value will cause a new tab * to be opened with the associated file. * @example * &lt;DocumentView * multiTabEnabled={true} * /&gt; */ multiTabEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Multi-tab * @type {string} * @optional * @default the file name * @desc Set the tab title if {@link DocumentView.multiTabEnabled multiTabEnabled} is true. * @example * &lt;DocumentView * multiTabEnabled={true} * tabTitle={'tab1'} * /&gt; */ tabTitle: PropTypes.string, /** * @memberof DocumentView * @category Multi-tab * @type {number} * @optional * @default unlimited * @desc Sets the limit on the maximum number of tabs that the viewer could have at a time. * Open more documents after reaching this limit will overwrite the old tabs. * @example * &lt;DocumentView * multiTabEnabled={true} * maxTabCount={5} * /&gt; */ maxTabCount: PropTypes.number, /** * @memberof DocumentView * @category Signature * @type {boolean} * @optional * @default false * @desc * Defines whether signature fields will be signed with image stamps. * This is useful if you are saving XFDF to remote source. * @example * &lt;DocumentView * signSignatureFieldsWithStamps={true} * /&gt; */ signSignatureFieldsWithStamps: PropTypes.bool, /** * @memberof DocumentView * @category Annotations * @type {boolean} * @optional * @default false * @desc Defines whether an annotation's permission flags will be respected when it is selected. * For example, a locked annotation can not be resized or moved. * @example * &lt;DocumentView * annotationPermissionCheckEnabled={true} * /&gt; */ annotationPermissionCheckEnabled: PropTypes.bool, /** * @type {Config.DefaultToolbars[]|object} * @category Toolbar Customization * @memberof DocumentView * @optional * @default Defaults to none. * @desc Type can be array of {@link Config.DefaultToolbars} constants or custom toolbar objects. * * Defines custom toolbars. If passed in, the default toolbars will no longer appear. * It is possible to mix and match with default toolbars. See example below. * @example * const myToolbar = { * [Config.CustomToolbarKey.Id]: 'myToolbar', * [Config.CustomToolbarKey.Name]: 'myToolbar', * [Config.CustomToolbarKey.Icon]: Config.ToolbarIcons.FillAndSign, * [Config.CustomToolbarKey.Items]: [Config.Tools.annotationCreateArrow, * Config.Tools.annotationCreateCallout, Config.Buttons.undo] * }; * ... * &lt;DocumentView * annotationToolbars={[Config.DefaultToolbars.Annotate, myToolbar]} * /&gt; */ annotationToolbars: PropTypes.arrayOf(PropTypes.oneOfType([ oneOf(Config.DefaultToolbars), PropTypes.exact({ id: PropTypes.string.isRequired, name: PropTypes.string.isRequired, icon: oneOf(Config.ToolbarIcons).isRequired, items: arrayOf(Config.Tools, Config.Buttons).isRequired }) ])), /** * @memberof DocumentView * @category Toolbar Customization * @type {Config.DefaultToolbars[]} * @optional * @default Defaults to none. * @desc Defines which default annotation toolbars should be hidden. * Note that this prop should be used when * {@link DocumentView.annotationToolbars annotationToolbars} is not defined. * @example * &lt;DocumentView * hideDefaultAnnotationToolbars={[Config.DefaultToolbars.Annotate, * Config.DefaultToolbars.Favorite]} * /&gt; */ hideDefaultAnnotationToolbars: arrayOf(Config.DefaultToolbars), /** * @memberof DocumentView * @category Toolbar Customization * @type {Config.Buttons[]} * @optional * @desc iOS only * * Customizes the right bar section of the top app nav bar. * If passed in, the default right bar section will not be used. * @example * &lt;DocumentView * topAppNavBarRightBar={[Config.Buttons.reflowButton, Config.Buttons.outlineListButton]} * /&gt; */ topAppNavBarRightBar: arrayOf(Config.Buttons), /** * @memberof DocumentView * @type {Config.Buttons[]} * @category Toolbar Customization * @optional * @desc Only the outline list, thumbnail list, share, view mode, * search, and reflow buttons are supported on Android. * * Defines a custom bottom toolbar. If passed in, the default bottom toolbar will not be used. * @example * &lt;DocumentView * bottomToolbar={[Config.Buttons.reflowButton, Config.Buttons.outlineListButton]} * /&gt; */ bottomToolbar: arrayOf(Config.Buttons), /** * @memberof DocumentView * @category Toolbar Customization * @type {boolean} * @optional * @default false * @desc Defines whether to show the toolbar switcher in the top toolbar. * @example * &lt;DocumentView * hideAnnotationToolbarSwitcher={false} * /&gt; */ hideAnnotationToolbarSwitcher: PropTypes.bool, /** * @memberof DocumentView * @category Toolbar Customization * @type {boolean} * @optional * @default false * @desc Defines whether to hide both the top app nav bar and the annotation toolbar. * @example * &lt;DocumentView * hideTopToolbars={false} * /&gt; */ hideTopToolbars: PropTypes.bool, /** * @memberof DocumentView * @category Toolbar Customization * @type {boolean} * @optional * @default false * @desc Defines whether to hide the top navigation app bar. * @example * &lt;DocumentView * hideTopAppNavBar={true} * /&gt; */ hideTopAppNavBar: PropTypes.bool, /** * @memberof DocumentView * @category Bookmark * @event * @type {function} * @optional * @desc This function is called if a change has been made to user bookmarks. * @param {string} bookmarkJson the list of current bookmarks in JSON format * @example * &lt;DocumentView * onBookmarkChanged = {({bookmarkJson}) =&gt; { * console.log('Bookmarks have been changed. Current bookmark collection is', bookmarkJson); * }} * /&gt; */ onBookmarkChanged: func(), /** * @memberof DocumentView * @category Thumbnails * @type {Config.ThumbnailFilterMode[]} * @optional * @desc Defines filter modes that should be hidden in the thumbnails browser. * @example * &lt;DocumentView * hideThumbnailFilterModes={[Config.ThumbnailFilterMode.Annotated]} * /&gt; */ hideThumbnailFilterModes: arrayOf(Config.ThumbnailFilterMode), /** * @memberof DocumentView * @category UI Customization * @event * @type {function} * @optional * @desc This function is called when the current tool changes to a new tool * @param {Config.Tools|string} previousTool the previous tool * (one of the {@link Config.Tools} constants or \"unknown tool\"), * representing the tool before change * @param {Config.Tools|string} tool the current tool (one of the {@link Config.Tools} constants * or \"unknown tool\"), representing the current tool * @example * &lt;DocumentView * onToolChanged = {({previousTool, tool}) =&gt; { * console.log('Tool has been changed from', previousTool, 'to', tool); * }} * /&gt; */ onToolChanged: func(), /** * @memberof DocumentView * @category Scroll * @type {number} * @optional * @desc Defines the horizontal scroll position in the current document viewer. * @example * &lt;DocumentView * horizontalScrollPos={50} * /&gt; */ horizontalScrollPos: PropTypes.number, /** * @memberof DocumentView * @category Scroll * @type {number} * @optional * @desc Defines the vertical scroll position in the current document viewer. * @example * &lt;DocumentView * verticalScrollPos={50} * /&gt; */ verticalScrollPos: PropTypes.number, /** * @memberof DocumentView * @category Text Selection * @event * @type {function} * @optional * @desc This function is called immediately before a text search begins, * either through user actions, or function calls such as {@link DocumentView#findText findText}. * @example * &lt;DocumentView * onTextSearchStart = {() =&gt; { * console.log('Text search has started'); * }} * /&gt; */ onTextSearchStart: func(), /** * @memberof DocumentView * @category Text Selection * @event * @type {function} * @optional * @desc This function is called after a text search is finished or canceled. * @param {boolean} found whether a result is found. * If false, it could be caused by not finding a matching result in the document, * invalid text input, or action cancellation * (user actions or {@link DocumentView#cancelFindText cancelFindText}) * @param {object} textSelection the text selection, in the format * `{html: string, unicode: string, pageNumber: number, * quads: [[{x: number, y: number}, {x: number, y: number}, {x: number, y: number}, * {x: number, y: number}], ...]}`. If no such selection could be found, this would be null * * Quads indicate the quad boundary boxes for the selection, * which could have a size larger than 1 if selection spans across different lines. * Each quad have 4 points with x, y coordinates specified in number, representing a boundary box. * The 4 points are in counter-clockwise order, though the first point is not guaranteed to be on * lower-left relatively to the box. * @example * &lt;DocumentView * onTextSearchResult = {({found, textSelection}) =&gt; { * if (found) { * console.log('Found selection on page', textSelection.pageNumber); * for (let i = 0; i &lt; textSelection.quads.length; i ++) { * const quad = textSelection.quads[i]; * console.log('selection boundary quad', i); * for (const quadPoint of quad) { * console.log('A quad point has coordinates', quadPoint.x, quadPoint.y); * } * } * } * }} * /&gt; */ onTextSearchResult: func(), /** * @memberof DocumentView * @category UI Customization * @type {Config.ViewModePickerItem[]} * @optional * @default Defaults to none. * @desc Defines view mode items to be hidden in the view mode dialog. * @example * &lt;DocumentView * hideViewModeItems={[ * Config.ViewModePickerItem.Crop, * Config.ViewModePickerItem.Rotation, * Config.ViewModePickerItem.ColorMode * ]} * /&gt; */ hideViewModeItems: arrayOf(Config.ViewModePickerItem), /** * @memberof DocumentView * @category Navigation * @type {boolean} * @optional * @default true * @desc Android only. * * Defines whether the page stack navigation buttons will appear in the viewer. * @example * &lt;DocumentView * pageStackEnabled={false} * /&gt; */ pageStackEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Navigation * @type {boolean} * @optional * @default true * @desc Defines whether the quick navigation buttons will appear in the viewer. * @example * &lt;DocumentView * showQuickNavigationButton={false} * /&gt; */ showQuickNavigationButton: PropTypes.bool, /** * @memberof DocumentView * @category Signature * @type {boolean} * @optional * @default true. * @desc Android only. * * Defines whether to show the option to pick images in the signature dialog. * @example * &lt;DocumentView * photoPickerEnabled={true} * /&gt; */ photoPickerEnabled: PropTypes.bool, /** * @memberof DocumentView * @type {boolean} * @optional * @default false * @desc Defines whether to automatically resize the bounding box of free * text annotations when editing. * @example * &lt;DocumentView * autoResizeFreeTextEnabled={true} * /&gt; */ autoResizeFreeTextEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Annotations * @type {boolean} * @optional * @default true * @desc Android only * * If document editing is enabled, then this value determines if the annotation list is editable. * @example * &lt;DocumentView * annotationsListEditingEnabled={true} * /&gt; */ annotationsListEditingEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Navigation * @type {boolean} * @optional * @default true on Android and false on iOS * @desc Defines whether the navigation list will be displayed as a side panel * on large devices such as iPads and tablets. * @example * &lt;DocumentView * showNavigationListAsSidePanelOnLargeDevices={true} * /&gt; */ showNavigationListAsSidePanelOnLargeDevices: PropTypes.bool, /** * @memberof DocumentView * @type {boolean} * @optional * @default false * @desc Defines whether to restrict data usage when viewing online PDFs. * @example * &lt;DocumentView * restrictDownloadUsage={true} * /&gt; */ restrictDownloadUsage: PropTypes.bool, /** * @memberof DocumentView * @category Bookmark * @type {boolean} * @optional * @default true * @desc Defines whether the bookmark list can be edited. * If the viewer is readonly then bookmarks on Android are * still editable but are saved to the device rather than the PDF. * @example * &lt;DocumentView * userBookmarksListEditingEnabled={true} * /&gt; */ userBookmarksListEditingEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Reflow * @type {boolean} * @optional * @default true * @desc Whether to show images in reflow mode. * @example * &lt;DocumentView * imageInReflowEnabled={false} * /&gt; */ imageInReflowEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Reflow * @type {Config.ReflowOrientation} * @optional * @default Config.ReflowOrientation.Horizontal * @desc Android only. * * Sets the scrolling direction of the reflow control. * @example * &lt;DocumentView * reflowOrientation={Config.ReflowOrientation.Vertical} * /&gt; */ reflowOrientation: oneOf(Config.ReflowOrientation), /** * @memberof DocumentView * @category Undo/Redo * @event * @type {function} * @optional * @desc This function is called when the state of the current document's * undo/redo stack has been changed. * @example * &lt;DocumentView * onUndoRedoStateChanged = {() =&gt; { * console.log(\"Undo/redo stack state changed\"); * }} * /&gt; */ onUndoRedoStateChanged: func(), /** * @memberof DocumentView * @category UI Customization * @type {boolean} * @optional * @default true * @desc Android only. * * Defines whether the tablet layout should be used on tablets. * Otherwise uses the same layout as phones. * @example * &lt;DocumentView * tabletLayoutEnabled={true} * /&gt; */ tabletLayoutEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Toolbar Customization * @type {Config.DefaultToolbars|string} * @optional * @default Defaults to none. * @desc Type can be one of the {@link Config.DefaultToolbars} constants * or the `id` of a custom toolbar object. * * Defines which {@link DocumentView.annotationToolbars annotationToolbar} * should be selected when the document is opened. * @example * &lt;DocumentView * initialToolbar={Config.DefaultToolbars.Draw} * /&gt; */ initialToolbar: PropTypes.string, /** * @memberof DocumentView * @category Annotations * @type {boolean} * @optional * @default true * @desc If true, ink tool will use multi-stroke mode. * Otherwise, each stroke is a new ink annotation. * @example * &lt;DocumentView * inkMultiStrokeEnabled={true} * /&gt; */ inkMultiStrokeEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Open a Document * @type {Config.EraserType} * @optional * @desc Sets the default eraser tool type. Value only applied after a clean * install. * Eraser Type | Description * --- | --- * `annotationEraser` | Erases everything as an object; if you touch ink, * the entire object is erased. * `hybrideEraser` | Erases ink by pixel, but erases other annotation types as objects. * `inkEraser` | Erases ink by pixel only. Android only. * @example * &lt;DocumentView * defaultEraserType={Config.EraserType.hybrideEraser} * /&gt; */ defaultEraserType: oneOf(Config.EraserType), /** * @memberof DocumentView * @category Open a Document * @type {string} * @optional * @desc Android only. * * Sets the folder path for all save options, this defaults to the app cache path. * Example: * @example * &lt;DocumentView * exportPath=\"/data/data/com.example/cache/test\" * /&gt; */ exportPath: PropTypes.string, /** * @memberof DocumentView * @category Open a Document * @type {string} * @optional * @desc Android only. * * Sets the cache folder used to cache PDF files opened using a http/https link, * this defaults to the app cache path. * @example * &lt;DocumentView * openUrlPath=\"/data/data/com.example/cache/test\" * /&gt; */ openUrlPath: PropTypes.string, /** * @memberof DocumentView * @category Annotations * @type {Config.Tools[]} * @optional * @default Defaults to none. * @desc Defines annotation types that cannot be edited after creation. * @example * &lt;DocumentView * disableEditingByAnnotationType={[Config.Tools.annotationCreateTextSquiggly, * Config.Tools.annotationCreateEllipse]} * /&gt; */ disableEditingByAnnotationType: arrayOf(Config.Tools), /** * @memberof DocumentView * @category Scroll * @type {boolean} * @optional * @default false * @desc iOS only. * * Determines whether scrollbars will be hidden on the viewer. * @example * &lt;DocumentView * hideScrollbars={true} * /&gt; */ hideScrollbars: PropTypes.bool, /** * @memberof DocumentView * @category Open a Document * @type {boolean} * @optional * @default true * @desc Sets whether to remember the last visited page and zoom for a * document if it gets opened again. * @example * &lt;DocumentView * saveStateEnabled={false} * /&gt; */ saveStateEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Open a Document * @type {boolean} * @optional * @default true * @desc Android only. * * Sets whether the new saved file should open after saving. * @example * &lt;DocumentView * openSavedCopyInNewTab={false} * /&gt; */ openSavedCopyInNewTab: PropTypes.bool, /** * @memberof DocumentView * @category Annotations * @type {Config.Tools[]} * @optional * @default Defaults to none. * @desc Defines types to be excluded from the annotation list. * @example * &lt;DocumentView * excludedAnnotationListTypes={[Config.Tools.annotationCreateEllipse, * Config.Tools.annotationCreateRectangle, * Config.Tools.annotationCreateRedaction]} * /&gt; */ excludedAnnotationListTypes: arrayOf(Config.Tools), /** * @memberof DocumentView * @category Collaboration * @type {boolean} * @optional * @default true * @desc Android only. * * Defines whether to show an annotation's reply review state. * @example * &lt;DocumentView * collabEnabled={true} * currentUser={'Pdftron'} * replyReviewStateEnabled={true} * /&gt; */ replyReviewStateEnabled: PropTypes.bool, /** * @memberof DocumentView * @category Page * @event * @type {function} * @optional * @desc This function is called when a page has been moved in the document. * @param {int} previousPageNumber the previous page number * @param {int} pageNumber the current page number * @example * &lt;DocumentView * onPageMoved = {({previousPageNumber, pageNumber}) =&gt; { * console.log('Page moved from', previousPageNumber, 'to', pageNumber); * }} * /&gt; */ onPageMoved: func(), /** * @memberof DocumentView * @category Multi-tab * @event * @type {function} * @optional * @desc The function is activated when a tab is changed. * * This API is meant for tab-specific changes. * If you would like to know when the document finishes loading instead, see * the {@link DocumentView.event:onDocumentLoaded onDocumentLoaded} event. * @param {string} currentTab The file path of current tab's document * @example * &lt;DocumentView * multiTabEnabled={true} * onTabChanged={({currentTab}) =&gt; { * console.log(\"The current tab is \", currentTab); * }} * /&gt; */ onTabChanged: func() }; /** * Creates a custom PropType for functions. * * If the resulting PropType is used to generate prop types for TS users, * type checking for function parameters and return values will be provided. * @returns {Requireable&lt;T&gt;} A custom PropType constant. * @example * func&lt;(path: string) =&gt; void&gt;() * @ignore */ function func() { const validator = function (props, propName, componentName, location, propFullName) { if (typeof props[propName] !== \"function\" &amp;&amp; typeof props[propName] !== \"undefined\") { return new Error(`Invalid prop \\`${propName}\\` of type \\`${typeof props[propName]}\\` supplied to \\`${componentName}\\`, expected a function.`); } return null; }; const t = validator; t.isRequired = validator; return t; } /** * Creates a custom PropType representing any value from given object(s). * @param {object} obj An object containing values. * @param {...object} rest Indefinite number of other objects containing values. * @returns {Requireable&lt;T&gt;} A custom PropType constant. * @example * oneOf&lt;Config.Tools&gt;(Config.Tools) * oneOf&lt;Config.Tools | Config.Buttons&gt;(Config.Tools, Config.Buttons) * @ignore */ function oneOf(obj, ...rest) { if (rest.length &gt; 0) { return PropTypes.oneOf(Object.values(Object.assign({}, obj, ...rest))); } return PropTypes.oneOf(Object.values(obj)); } /** * Creates a custom PropType representing any array containing values from given object(s). * @param {object} obj An object containing values. * @param {...object} rest Indefinite number of other objects containing values. * @returns {Requireable&lt;T[]&gt;} A custom PropType constant. * @example * arrayOf&lt;Config.Tools&gt;(Config.Tools) * arrayOf&lt;Config.Tools | Config.Buttons&gt;(Config.Tools, Config.Buttons) * @ignore */ function arrayOf(obj, ...rest) { return PropTypes.arrayOf(oneOf(obj, ...rest)); } /** * @class * @classdesc An all-in-one React component for displaying and editing documents of different types * such as PDF, docx, pptx, xlsx and various image formats. * * Due to the length of the source file, we have included links to the exact lines of the source * code where these APIs have been implemented. * @hideconstructor */ export class DocumentView extends PureComponent { _viewerRef; static propTypes = Object.assign(DocumentViewPropTypes, { ...ViewPropTypes }); onChange = (event) =&gt; { if (event.nativeEvent.onLeadingNavButtonPressed) { if (this.props.onLeadingNavButtonPressed) { this.props.onLeadingNavButtonPressed(); } } else if (event.nativeEvent.onDocumentLoaded) { if (this.props.onDocumentLoaded) { this.props.onDocumentLoaded(event.nativeEvent.onDocumentLoaded); } } else if (event.nativeEvent.onPageChanged) { if (this.props.onPageChanged) { this.props.onPageChanged({ 'previousPageNumber': event.nativeEvent.previousPageNumber, 'pageNumber': event.nativeEvent.pageNumber }); } } else if (event.nativeEvent.onScrollChanged) { if (this.props.onScrollChanged) { this.props.onScrollChanged({ 'horizontal': event.nativeEvent.horizontal, 'vertical': event.nativeEvent.vertical }); } } else if (event.nativeEvent.onZoomChanged) { if (this.props.onZoomChanged) { this.props.onZoomChanged({ 'zoom': event.nativeEvent.zoom }); } } else if (event.nativeEvent.onZoomFinished) { if (this.props.onZoomFinished) { this.props.onZoomFinished({ 'zoom': event.nativeEvent.zoom }); } } else if (event.nativeEvent.onLayoutChanged) { if (this.props.onLayoutChanged) { this.props.onLayoutChanged(); } } else if (event.nativeEvent.onAnnotationChanged) { if (this.props.onAnnotationChanged) { this.props.onAnnotationChanged({ 'action': event.nativeEvent.action, 'annotations': event.nativeEvent.annotations }); } } else if (event.nativeEvent.onAnnotationsSelected) { if (this.props.onAnnotationsSelected) { this.props.onAnnotationsSelected({ 'annotations': event.nativeEvent.annotations }); } } else if (event.nativeEvent.onFormFieldValueChanged) { if (this.props.onFormFieldValueChanged) { this.props.onFormFieldValueChanged({ 'fields': event.nativeEvent.fields }); } } else if (event.nativeEvent.onDocumentError) { if (this.props.onDocumentError) { this.props.onDocumentError(event.nativeEvent.onDocumentError); } else { const error = 'Unknown error'; const msg = event.nativeEvent.onDocumentError ? event.nativeEvent.onDocumentError : error; Alert.alert('Alert', msg, [ { text: 'OK' } ], { cancelable: true }); } } else if (event.nativeEvent.onExportAnnotationCommand) { if (this.props.onExportAnnotationCommand) { this.props.onExportAnnotationCommand({ 'action': event.nativeEvent.action, 'xfdfCommand': event.nativeEvent.xfdfCommand, 'annotations': event.nativeEvent.annotations }); } } else if (event.nativeEvent.onAnnotationMenuPress) { if (this.props.onAnnotationMenuPress) { this.props.onAnnotationMenuPress({ 'annotationMenu': event.nativeEvent.annotationMenu, 'annotations': event.nativeEvent.annotations }); } } else if (event.nativeEvent.onLongPressMenuPress) { if (this.props.onLongPressMenuPress) { this.props.onLongPressMenuPress({ 'longPressMenu': event.nativeEvent.longPressMenu, 'longPressText': event.nativeEvent.longPressText }); } } else if (event.nativeEvent.onBehaviorActivated) { if (this.props.onBehaviorActivated) { this.props.onBehaviorActivated({ 'action': event.nativeEvent.action, 'data': event.nativeEvent.data }); } } else if (event.nativeEvent.onBookmarkChanged) { if (this.props.onBookmarkChanged) { this.props.onBookmarkChanged({ 'bookmarkJson': event.nativeEvent.bookmarkJson }); } } else if (event.nativeEvent.onToolChanged) { if (this.props.onToolChanged) { this.props.onToolChanged({ 'previousTool': event.nativeEvent.previousTool, 'tool': event.nativeEvent.tool }); } } else if (event.nativeEvent.onTextSearchStart) { if (this.props.onTextSearchStart) { this.props.onTextSearchStart(); } } else if (event.nativeEvent.onTextSearchResult) { if (this.props.onTextSearchResult) { this.props.onTextSearchResult({ 'found': event.nativeEvent.found, 'textSelection': event.nativeEvent.textSelection }); } } else if (event.nativeEvent.onUndoRedoStateChanged) { if (this.props.onUndoRedoStateChanged) { this.props.onUndoRedoStateChanged(); } } else if (event.nativeEvent.onPageMoved) { if (this.props.onPageMoved) { this.props.onPageMoved({ 'previousPageNumber': event.nativeEvent.previousPageNumber, 'pageNumber': event.nativeEvent.pageNumber }); } } else if (event.nativeEvent.onTabChanged) { if (this.props.onTabChanged) { this.props.onTabChanged({ 'currentTab': event.nativeEvent.currentTab }); } } }; // Methods /** * @method * @category Document * @desc Returns the path of the current document. * If {@link DocumentView.isBase64String isBase64String} is true, * this would be the path to the temporary pdf file converted from * the base64 string in {@link DocumentView.document document}. * @returns {Promise&lt;void | string&gt;} path - the document path. * @example * this._viewer.getDocumentPath().then((path) =&gt; { * console.log('The path to current document is: ' + path); * }); */ getDocumentPath = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getDocumentPath(tag); } return Promise.resolve(); }; /** * @method * @category Annotation Tools * @desc Sets the current tool mode. * @param {Config.Tools} toolMode the tool mode to set. * @returns {Promise&lt;void&gt;} * @example * this._viewer.setToolMode(Config.Tools.annotationCreateFreeHand).then(() =&gt; { * // done switching tools * }); */ setToolMode = (toolMode) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setToolMode(tag, toolMode); } return Promise.resolve(); }; /** * @method * @category Annotation Tools * @desc Commits the current tool, only available for multi-stroke ink and poly-shape. * @returns {Promise&lt;void | boolean&gt;} committed - true if either ink or poly-shape tool is * committed, false otherwise * @example * this._viewer.commitTool().then((committed) =&gt; { * // committed: true if either ink or poly-shape tool is committed, false otherwise * }); */ commitTool = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.commitTool(tag); } return Promise.resolve(); }; /** * @method * @category Page * @desc Gets the current page count of the document. * @returns {Promise&lt;void | number&gt;} pageCount - the current page count of the document * @example * this._viewer.getPageCount().then((pageCount) =&gt; { * console.log('pageCount', pageCount); * }); */ getPageCount = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getPageCount(tag); } return Promise.resolve(); }; /** * @method * @category Bookmark * @desc Imports user bookmarks into the document. * The input needs to be a valid bookmark JSON format. * @param {string} bookmarkJson needs to be in valid bookmark JSON format, * for example {\"0\": \"Page 1\"}. The page numbers are 1-indexed * @returns {Promise&lt;void&gt;} * @example * this._viewer.importBookmarkJson(\"{\\\"0\\\": \\\"Page 1\\\", \\\"3\\\": \\\"Page 4\\\"}\"); */ importBookmarkJson = (bookmarkJson) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.importBookmarkJson(tag, bookmarkJson); } return Promise.resolve(); }; /** * @method * @category Bookmark * @desc Displays the bookmark tab of the existing list container. * If this tab has been disabled, the method does nothing. * @returns {Promise&lt;void&gt;} * @example * this._viewer.openBookmarkList(); */ openBookmarkList = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.openBookmarkList(tag); } return Promise.resolve(); }; /** * @method * @category Import/Export Annotations * @desc Imports remote annotation command to local document. * @param {string} xfdfCommand the XFDF command string * @param {boolean} [initialLoad=false] whether this is for initial load. * @returns {Promise&lt;void&gt;} * @example * const xfdfCommand = '&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;' + * '&lt;xfdf xmlns=\"http://ns.adobe.com/xfdf/\" xml:space=\"preserve\"&gt;' + * '&lt;add&gt;&lt;circle style=\"solid\" width=\"5\" color=\"#E44234\" opacity=\"1\" ' + * 'creationdate=\"D:20201218025606Z\" flags=\"print\" date=\"D:20201218025606Z\" ' + * 'name=\"9d0f2d63-a0cc-4f06-b786-58178c4bd2b1\" page=\"0\" ' + * 'rect=\"56.4793,584.496,208.849,739.369\" title=\"PDF\" /&gt;&lt;/add&gt;&lt;modify /&gt;&lt;delete /&gt;' + * '&lt;pdf-info import-version=\"3\" version=\"2\" xmlns=\"http://www.pdftron.com/pdfinfo\" /&gt;&lt;/xfdf&gt;'; * this._viewer.importAnnotationCommand(xfdfCommand); */ importAnnotationCommand = (xfdfCommand, initialLoad) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { if (initialLoad === undefined) { initialLoad = false; } return DocumentViewManager.importAnnotationCommand(tag, xfdfCommand, initialLoad); } return Promise.resolve(); }; /** * @method * @category Import/Export Annotations * @desc Imports XFDF annotation string to the current document. * @param {string} xfdf annotation string in XFDF format for import * @returns {Promise&lt;void&gt;} * @example * const xfdf = '&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\\n' + * '&lt;xfdf xmlns=\"http://ns.adobe.com/xfdf/\" xml:space=\"preserve\"&gt;\\n\\t&lt;annots&gt;\\n\\t\\t' + * '&lt;circle style=\"solid\" width=\"5\" color=\"#E44234\" opacity=\"1\" ' + * 'creationdate=\"D:20190729202215Z\" flags=\"print\" date=\"D:20190729202215Z\" page=\"0\" ' + * 'rect=\"138.824,653.226,236.28,725.159\" title=\"\" /&gt;&lt;/annots&gt;\\n\\t&lt;pages&gt;\\n\\t\\t' + * '&lt;defmtx matrix=\"1.333333,0.000000,0.000000,-1.333333,0.000000,1056.000000\" /&gt;\\n\\t&lt;/pages&gt;' + * '\\n\\t&lt;pdf-info version=\"2\" xmlns=\"http://www.pdftron.com/pdfinfo\" /&gt;\\n&lt;/xfdf&gt;'; * this._viewer.importAnnotations(xfdf); */ importAnnotations = (xfdf) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.importAnnotations(tag, xfdf); } return Promise.resolve(); }; /** * @method * @category Import/Export Annotations * @desc Extracts XFDF from the current document. * @param {object} options key: annotList, type: array. * If specified, annotations with the matching id and pageNumber will be exported; * otherwise, all annotations in the current document will be exported. * @returns {Promise&lt;void | string&gt;} xfdf - annotation string in XFDF format * @example &lt;caption&gt;Without options:&lt;/caption&gt; * this._viewer.exportAnnotations().then((xfdf) =&gt; { * console.log('XFDF for all annotations:', xfdf); * }); * @example &lt;caption&gt;With options:&lt;/caption&gt; * // annotList is an array of annotation data in the format {id: string, pageNumber: int} * const annotations = [{id: 'annot1', pageNumber: 1}, {id: 'annot2', pageNumber: 3}]; * this._viewer.exportAnnotations({annotList: annotations}).then((xfdf) =&gt; { * console.log('XFDF for 2 specified annotations', xfdf); * }); */ exportAnnotations = (options) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.exportAnnotations(tag, options); } return Promise.resolve(); }; /** * @method * @category Annotations * @desc Flattens the forms and (optionally) annotations in the current document. * @param {boolean} formsOnly Defines whether only forms are flattened. * If false, all annotations will be flattened. * @returns {Promise&lt;void&gt;} * @example * // flatten forms and annotations in the current document. * this._viewer.flattenAnnotations(false); */ flattenAnnotations = (formsOnly) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.flattenAnnotations(tag, formsOnly); } return Promise.resolve(); }; /** * @method * @category Annotations * @desc Deletes the specified annotations in the current document. * @param {object[]} annotations Defines which annotation to be deleted. * Each element is in the format {id: string, pageNumber: int} * @returns {Promise&lt;void&gt;} * @example * // delete annotations in the current document. * this._viewer.deleteAnnotations([ * { * id: 'annotId1', * pageNumber: 1, * }, * { * id: 'annotId2', * pageNumber: 2, * } * ]); */ deleteAnnotations = (annotations) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.deleteAnnotations(tag, annotations); } return Promise.resolve(); }; /** * @method * @category Document * @desc Saves the current document. * If {@link DocumentView.isBase64String isBase64String} is true, * this would be the base64 string encoded from the temporary pdf file, * which is created from the base64 string in {@link DocumentView.document document}. * @returns {Promise&lt;void | string&gt;} filePath - the location of the saved document, * or the base64 string of the pdf in the case of base64 * @example * this._viewer.saveDocument().then((filePath) =&gt; { * console.log('saveDocument:', filePath); * }); */ saveDocument = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.saveDocument(tag); } return Promise.resolve(); }; /** * @method * @category Annotations * @desc Sets a field flag value on one or more form fields. * @param {string[]} fields list of field names for which the flag should be set * @param {Config.FieldFlags} flag flag to be set * @param {boolean} value value to set for flag * @returns {Promise&lt;void&gt;} * @example * this._viewer.setFlagForFields(['First Name', 'Last Name'], Config.FieldFlags.ReadOnly, true); */ setFlagForFields = (fields, flag, value) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setFlagForFields(tag, fields, flag, value); } return Promise.resolve(); }; /** * @method * @category Annotations * @desc Get type and value information of a field using its name. * @param {string} fieldName name of the field * @returns {Promise&lt;void | object&gt;} field - an object with information keys: * `fieldName`, `fieldValue` (undefined for fields with no values) and * `fieldType`(one of button, checkbox, radio, text, choice, signature and unknown), * or undefined if such field does not exist * * @example * this._viewer.getField('someFieldName').then((field) =&gt; { * if (field !== undefined) { * console.log('field name:', field.fieldName); * console.log('field value:', field.fieldValue); * console.log('field type:', field.fieldType); * } * }); */ getField = (fieldName) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getField(tag, fieldName); } return Promise.resolve(); }; /** * @method * @category Annotations * @desc Displays the annotation tab of the existing list container. * If this tab has been disabled, the method does nothing. * @returns {Promise&lt;void&gt;} * @example * this._viewer.openAnnotationList(); */ openAnnotationList = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.openAnnotationList(tag); } return Promise.resolve(); }; /** * @method * @deprecated Note: this function exists for supporting the old version. * It simply calls {@link DocumentView#setValuesForFields setValuesForFields}. * @ignore */ setValueForFields = (fieldsMap) =&gt; { return this.setValuesForFields(fieldsMap); }; /** * @method * @category Annotations * @desc Sets field values on one or more form fields. * * Note: the old function `setValueForFields` is deprecated. Please use this one instead. * @param {object} fieldsMap map of field names and values which should be set * @returns {Promise&lt;void&gt;} * @example * this._viewer.setValuesForFields({ * 'textField1': 'Test', * 'textField2': 1234, * 'checkboxField1': true, * 'checkboxField2': false, * 'radioButton1': 'Yes', * 'radioButton2': 'No' * }); */ setValuesForFields = (fieldsMap) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setValuesForFields(tag, fieldsMap); } return Promise.resolve(); }; /** * @method * @category Navigation * @desc Handles the back button in search mode. Android only. * @returns {Promise&lt;void | boolean&gt;} handled - whether the back button is handled successfully * @example * this._viewer.handleBackButton().then((handled) =&gt; { * if (!handled) { * BackHandler.exitApp(); * } * }); */ handleBackButton = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.handleBackButton(tag); } return Promise.resolve(); }; /** * @method * @deprecated Note: this function exists for supporting the old version. * It simply calls {@link DocumentView#setFlagsForAnnotations setFlagsForAnnotations}. * @ignore */ setFlagForAnnotations = (annotationFlagList) =&gt; { return this.setFlagsForAnnotations(annotationFlagList); }; /** * @method * @category Annotations * @desc Sets flags for specified annotations in the current document. * The `flagValue` controls whether a flag will be set to or removed from the annotation. * * Note: the old function `setFlagForAnnotations` is deprecated. Please use this one. * * @param {object[]} annotationFlagList A list of annotation flag operations. * Each element is in the format * `{id: string, pageNumber: int, * flag: One of {@link Config.AnnotationFlags} constants, flagValue: boolean}` * @returns {Promise&lt;void&gt;} * @example * // Set flag for annotations in the current document. * this._viewer.setFlagsForAnnotations([ * { * id: 'annotId1', * pageNumber: 1, * flag: Config.AnnotationFlags.noView, * flagValue: true * }, * { * id: 'annotId2', * pageNumber: 5, * flag: Config.AnnotationFlags.lockedContents, * flagValue: false * } * ]); */ setFlagsForAnnotations = (annotationFlagList) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setFlagsForAnnotations(tag, annotationFlagList); } return Promise.resolve(); }; /** * @method * @category Annotations * @desc Selects the specified annotation in the current document. * @param {string} id the id of the target annotation * @param {integer} pageNumber the page number where the targe annotation is located. * It is 1-indexed. * @returns {Promise&lt;void&gt;} * @example * // select annotation in the current document. * this._viewer.selectAnnotation('annotId1', 1); */ selectAnnotation = (id, pageNumber) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.selectAnnotation(tag, id, pageNumber); } return Promise.resolve(); }; /** * @method * @deprecated Note: this function exists for supporting the old version. * It simply calls setPropertiesForAnnotation. * @ignore */ setPropertyForAnnotation = (id, pageNumber, propertyMap) =&gt; { return this._viewerRef.setPropertiesForAnnotation(id, pageNumber, propertyMap); }; /** * @method * @category Annotations * @desc Sets properties for specified annotation in the current document, if it is valid. * * Note: the old function `setPropertyForAnnotation` is deprecated. Please use this one. * * @param {string} annotationId the unique id of the annotation * @param {integer} pageNumber the page number where annotation is located. It is 1-indexed * @param {object} propertyMap an object containing properties to be set. * Available properties are listed below. * * Properties in propertyMap: * * Name | Type | Markup exclusive | Example * --- | --- | --- | --- * rect | object | no | {x1: 1, y1: 2, x2: 3, y2: 4} * contents | string | no | \"contents\" * subject | string | yes | \"subject\" * title | string | yes | \"title\" * contentRect | object | yes | {x1: 1, y1: 2, x2: 3, y2: 4} * customData | object | no | {key: value} * strokeColor | object | no | {red: 255, green: 0, blue: 0} * * @returns {Promise&lt;void&gt;} * @example * // Set properties for annotation in the current document. * this._viewer.setPropertiesForAnnotation('Pdftron', 1, { * rect: { * x1: 1.1, // left * y1: 3, // bottom * x2: 100.9, // right * y2: 99.8 // top * }, * contents: 'Hello World', * subject: 'Sample', * title: 'set-prop-for-annot', * customData: { * key1: 'value1', * key2: 'value2', * key3: 'value3' * }, * strokeColor: { * \"red\": 255, * \"green\": 0, * \"blue\": 0 * } * }); */ setPropertiesForAnnotation = (id, pageNumber, propertyMap) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setPropertiesForAnnotation(tag, id, pageNumber, propertyMap); } return Promise.resolve(); }; /** * @method * @category Annotations * @desc Gets properties for specified annotation in the current document, if it is valid. * * @param {string} annotationId the unique id of the annotation * @param {integer} pageNumber the page number where annotation is located. It is 1-indexed * @returns {Promise&lt;void | object&gt;} propertyMap - the non-null properties of the annotation * * Name | Type | Markup exclusive | Example * --- | --- | --- | --- * rect | object | no | {x1: 1, y1: 1, x2: 2, y2: 2, width: 1, height: 1} * contents | string | no | \"Contents\" * subject | string | yes | \"Subject\" * title | string | yes | \"Title\" * contentRect | object | yes | {x1: 1, y1: 1, x2: 2, y2: 2, width: 1, height: 1} * strokeColor | object | no | {red: 255, green: 0, blue: 0} * @example * // Get properties for annotation in the current document. * this._viewer.getPropertiesForAnnotation('Pdftron', 1).then((properties) =&gt; { * if (properties) { * console.log('Properties for annotation: ', properties); * } * }) */ getPropertiesForAnnotation = (id, pageNumber) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getPropertiesForAnnotation(tag, id, pageNumber); } return Promise.resolve(); }; /** * @method * @category Annotations * @desc Sets whether all annotations and forms should be rendered. * This method affects the viewer and does not change the document. * * Unlike {@link DocumentView#setVisibilityForAnnotation setVisibilityForAnnotation}, * this method is used to show and hide all annotations and forms in the viewer. * @param {boolean} drawAnnotations whether all annotations and forms should be rendered * @returns {Promise&lt;void&gt;} * @example * this._viewer.setDrawAnnotations(false); */ setDrawAnnotations = (drawAnnotations) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setDrawAnnotations(tag, drawAnnotations); } return Promise.resolve(); }; /** * @method * @category Annotations * @desc Sets visibility for specified annotation in the current document, if it is valid. * Note that if {@link DocumentView#setDrawAnnotations drawAnnotations} * is set to false in the viewer, this function would not render the annotation even * if visibility is true. * * @param {string} annotationId the unique id of the annotation * @param {integer}pageNumber the page number where annotation is located. It is 1-indexed * @param {boolean }visibility whether the annotation should be visible * @returns {Promise&lt;void&gt;} * @example * this._viewer.setVisibilityForAnnotation('Pdftron', 1, true); */ setVisibilityForAnnotation = (id, pageNumber, visibility) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { DocumentViewManager.setVisibilityForAnnotation(tag, id, pageNumber, visibility); } return Promise.resolve(); }; /** * @method * @category Annotations * @desc Enables or disables highlighting form fields. It is disabled by default. * @param {boolean} highlightFields whether form fields should be highlighted * @example * this._viewer.setHighlightFields(true); */ setHighlightFields = (highlightFields) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { DocumentViewManager.setHighlightFields(tag, highlightFields); } return Promise.resolve(); }; /** * @method * @category Annotations * @desc Gets an annotation at the (x, y) position in screen coordinates, if any. * @param {integer} x the x-coordinate of the point * @param {integer} y the y-coordinate of the point * @param {double} distanceThreshold maximum distance from the point (x, y) * to the annotation for it to be considered a hit (in dp) * @param {double} minimumLineWeight For very thin lines, * it is almost impossible to hit the actual line. * This specifies a minimum line thickness (in screen coordinates) for the purpose of calculating * whether a point is inside the annotation or not (in dp) * @returns {Promise&lt;void | object&gt;} annotation - the annotation found in the format of * `{id: string, pageNumber: number, type: string, * screenRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}, * pageRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}}`. * * `type` is one of the {@link Config.Tools} constants. * * `screenRect` was formerly called `rect`. * @example * this._viewer.getAnnotationAtPoint(167, 287, 100, 10).then((annotation) =&gt; { * if (annotation) { * console.log('Annotation found at point (167, 287) has id:', annotation.id); * } * }) */ getAnnotationAtPoint = (x, y, distanceThreshold, minimumLineWeight) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getAnnotationAt(tag, x, y, distanceThreshold, minimumLineWeight); } return Promise.resolve(); }; /** * @method * @category Annotations * @desc Gets the list of annotations at a given line in screen coordinates. * Note that this is not an area selection. It should be used similar * to {@link DocumentView#getAnnotationAtPoint getAnnotationAtPoint}, except that this should * be used when you want to get multiple annotations which are overlaying with each other. * @param {integer} x1 x-coordinate of an endpoint on the line * @param {integer} y1 y-coordinate of an endpoint on the line * @param {integer} x2 x-coordinate of the other endpoint on the line, usually used as a threshold * @param {integer} y2 y-coordinate of the other endpoint on the line, usually used as a threshold * @returns {Promise&lt;void | object[]&gt;} annotations - list of annotations at the target line, * each in the format of `{id: string, pageNumber: number, type: string, * screenRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}, * pageRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}}`. * * `type` is one of the {@link Config.Tools} constants. * * `screenRect` was formerly called `rect`. * @example * this._viewer.getAnnotationListAt(0, 0, 200, 200).then((annotations) =&gt; { * for (const annotation of annotations) { * console.log('Annotation found at line has id:', annotation.id); * } * }) */ getAnnotationListAt = (x1, y1, x2, y2) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getAnnotationListAt(tag, x1, y1, x2, y2); } return Promise.resolve(); }; /** * @method * @category Annotations * @desc Gets the list of annotations on a given page. * @param {integer} pageNumber the page number where annotations are located. It is 1-indexed * @returns {Promise&lt;void | Array&lt;object&gt;&gt;} annotations - list of annotations on the target page, * each in the format of `{id: string, pageNumber: number, type: string, * screenRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}, * pageRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}}`. * * `type` is one of the {@link Config.Tools} constants. * * `screenRect` was formerly called `rect`. * @example * this._viewer.getAnnotationsOnPage(2).then((annotations) =&gt; { * for (const annotation of annotations) { * console.log('Annotation found on page 2 has id:', annotation.id); * } * }) */ getAnnotationsOnPage = (pageNumber) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getAnnotationListOnPage(tag, pageNumber); } return Promise.resolve(); }; /** * @method * @category Annotations * @desc Gets an annotation's `customData` property. * @param {string} annotationId the unique id of the annotation * @param {integer} pageNumber the page number where annotation is located. It is 1-indexed * @param {string} key the unique key associated with the `customData` property * @returns {Promise&lt;void | string&gt;} value - the `customData` property associated * with the given key * @example * this._viewer.setPropertiesForAnnotation(\"annotation1\", 2, { * customData: { * data: \"Nice annotation\" * } * }).then(() =&gt; { * this._viewer.getCustomDataForAnnotation(\"annotation1\", 2, \"data\").then((value) =&gt; { * console.log(value === \"Nice annotation\"); * }) * }) */ getCustomDataForAnnotation = (annotationID, pageNumber, key) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getCustomDataForAnnotation(tag, annotationID, pageNumber, key); } return Promise.resolve(); }; /** * @method * @category Page * @desc Gets the crop box for specified page as a JSON object. * @param {integer} pageNumber the page number for the target crop box. It is 1-indexed * @returns {Promise&lt;void | object&gt;} cropBox - an object with information about position * (`x1`, `y1`, `x2` and `y2`) and size (`width` and `height`) * @example * this._viewer.getPageCropBox(1).then((cropBox) =&gt; { * console.log('bottom-left coordinate:', cropBox.x1, cropBox.y1); * console.log('top-right coordinate:', cropBox.x2, cropBox.y2); * console.log('width and height:', cropBox.width, cropBox.height); * }); */ getPageCropBox = (pageNumber) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getPageCropBox(tag, pageNumber); } return Promise.resolve(); }; /** * @method * @category Page * @desc Sets current page of the document. * @param {integer} pageNumber the page number to be set as the current page; 1-indexed * @returns {Promise&lt;void | boolean&gt;} success - whether the setting process was successful * @example * this._viewer.setCurrentPage(4).then((success) =&gt; { * if (success) { * console.log(\"Current page is set to 4.\"); * } * }); */ setCurrentPage = (pageNumber) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setCurrentPage(tag, pageNumber); } return Promise.resolve(); }; /** * @method * @category Page * @desc Gets the visible pages in the current viewer as an array. * @returns {Promise&lt;void | Array&lt;number&gt;&gt;} visiblePages - a list of visible pages in the * current viewer * @example * this._viewer.getVisiblePages().then((visiblePages) =&gt; { * for (const page of visiblePages) { * console.log('page', page, 'is visible.') * } * }); */ getVisiblePages = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getVisiblePages(tag); } return Promise.resolve(); }; /** * @method * @category Page * @desc Go to the previous page of the document. If on first page, it will stay on first page. * @returns {Promise&lt;void | boolean&gt;} success - whether the setting process was successful * (no change due to staying in first page counts as being successful) * @example * this._viewer.gotoPreviousPage().then((success) =&gt; { * if (success) { * console.log(\"Go to previous page.\"); * } * }); */ gotoPreviousPage = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.gotoPreviousPage(tag); } return Promise.resolve(); }; /** * @method * @category Page * @desc Go to the next page of the document. If on last page, it will stay on last page. * @returns {Promise&lt;void | boolean&gt;} success - whether the setting process was successful * (no change due to staying in last page counts as being successful) * @example * this._viewer.gotoNextPage().then((success) =&gt; { * if (success) { * console.log(\"Go to next page.\"); * } * }); */ gotoNextPage = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.gotoNextPage(tag); } return Promise.resolve(); }; /** * @method * @category Page * @desc Go to the first page of the document. * @returns {Promise&lt;void | boolean&gt;} success - whether the setting process was successful * @example * this._viewer.gotoFirstPage().then((success) =&gt; { * if (success) { * console.log(\"Go to first page.\"); * } * }); */ gotoFirstPage = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.gotoFirstPage(tag); } return Promise.resolve(); }; /** * @method * @category Page * @desc Go to the last page of the document. * @returns {Promise&lt;void | boolean&gt;} success - whether the setting process was successful * @example * this._viewer.gotoLastPage().then((success) =&gt; { * if (success) { * console.log(\"Go to last page.\"); * } * }); */ gotoLastPage = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.gotoLastPage(tag); } return Promise.resolve(); }; /** * @method * @category Page * @desc Opens a go-to page dialog. If the user inputs a valid page number into the dialog, * the viewer will go to that page. * @returns {Promise&lt;void&gt;} * @example * this._viewer.showGoToPageView(); */ showGoToPageView = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.showGoToPageView(tag); } return Promise.resolve(); }; /** * @method * @category Multi-tab * @desc Closes all tabs in a multi-tab environment. * @returns {Promise&lt;void&gt;} * @example * // Do this only when DocumentView has multiTabEnabled = true * this._viewer.closeAllTabs(); */ closeAllTabs = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.closeAllTabs(tag); } return Promise.resolve(); }; /** * @method * @category Multi-tab * @desc Opens the tab switcher in a multi-tab environment. * @returns {Promise&lt;void&gt;} * @example * // Do this only when DocumentView has multiTabEnabled = true * this._viewer.openTabSwitcher(); */ openTabSwitcher = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.openTabSwitcher(tag); } return Promise.resolve(); }; /** * @method * @category Zoom * @desc Returns the current zoom scale of current document viewer. * @returns {Promise&lt;void | number&gt;} zoom - current zoom scale in the viewer * @example * this._viewer.getZoom().then((zoom) =&gt; { * console.log('Zoom scale of the current document is:', zoom); * }); */ getZoom = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getZoom(tag); } return Promise.resolve(); }; /** * @method * @category Zoom * @desc Sets the minimum and maximum zoom bounds of current viewer. * @param {Config.ZoomLimitMode} zoomLimitMode defines whether bounds are relative to the * standard zoom scale in the current viewer or absolute * @param {double} minimum the lower bound of the zoom limit range * @param {double} maximum the upper bound of the zoom limit range * @returns {Promise&lt;void&gt;} * @example * this._viewer.setZoomLimits(Config.ZoomLimitMode.Absolute, 1.0, 3.5); */ setZoomLimits = (zoomLimitMode, minimum, maximum) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setZoomLimits(tag, zoomLimitMode, minimum, maximum); } return Promise.resolve(); }; /** * @method * @category Zoom * @desc Sets the zoom scale in the current document viewer with a zoom center. * @param {double} zoom the zoom ratio to be set * @param {int} x the x-coordinate of the zoom center * @param {int} y the y-coordinate of the zoom center * @returns {Promise&lt;void&gt;} * @example * this._viewer.zoomWithCenter(3.0, 100, 300); */ zoomWithCenter = (zoom, x, y) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.zoomWithCenter(tag, zoom, x, y); } return Promise.resolve(); }; /** * @method * @category Zoom * @desc Zoom the viewer to a specific rectangular area in a page. * @param {int} pageNumber the page number of the zooming area (1-indexed) * @param {object} rect The rectangular area with keys * `x1` (left), `y1` (bottom), `y1` (right), `y2` (top). Coordinates are in double * @returns {Promise&lt;void&gt;} * @example * this._viewer.zoomToRect(3, {'x1': 1.0, 'y1': 2.0, 'x2': 3.0, 'y2': 4.0}); */ zoomToRect = (pageNumber, rect) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.zoomToRect(tag, pageNumber, rect); } return Promise.resolve(); }; /** * @method * @category Zoom * @desc Zoom to a paragraph that contains the specified coordinate. * If no paragraph contains the coordinate, the zooming would not happen. * @param {int} x the x-coordinate of the target coordinate * @param {int} y the y-coordinate of the target coordinate * @param {boolean} animated whether the transition is animated * @returns {Promise&lt;void&gt;} * @example * this._viewer.smartZoom(100, 200, true); */ smartZoom = (x, y, animated) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.smartZoom(tag, x, y, animated); } return Promise.resolve(); }; /** * @method * @category Scroll * @desc Returns the horizontal and vertical scroll position of current document viewer. * @returns {Promise&lt;void | object&gt;} * * Name | Type | Description * --- | --- | --- * horizontal | number | current horizontal scroll position * vertical | number | current vertical scroll position * * @example * this._viewer.getScrollPos().then(({horizontal, vertical}) =&gt; { * console.log('Current horizontal scroll position is:', horizontal); * console.log('Current vertical scroll position is:', vertical); * }); */ getScrollPos = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getScrollPos(tag); } return Promise.resolve(); }; /** * @method * @category Canvas * @desc Returns the canvas size of current document viewer. * @returns {Promise&lt;void | object&gt;} * * Name | Type | Description * --- | --- | --- * width | number | current width of canvas * height | number | current height of canvas * * @example * this._viewer.getCanvasSize().then(({width, height}) =&gt; { * console.log('Current canvas width is:', width); * console.log('Current canvas height is:', height); * }); */ getCanvasSize = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getCanvasSize(tag); } return Promise.resolve(); }; /** * @method * @category Page * @desc Gets the rotation value of all pages in the current document. * @returns {Promise&lt;void | number&gt;} pageRotation - the rotation degree of all pages, * one of 0, 90, 180 or 270 (clockwise). * @example * this._viewer.getPageRotation().then((pageRotation) =&gt; { * console.log('The current page rotation degree is' + pageRotation); * }); */ getPageRotation = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getPageRotation(tag); } return Promise.resolve(); }; /** * @method * @category Page * @desc Rotates all pages in the current document in clockwise direction (by 90 degrees). * @returns {Promise&lt;void&gt;} * @example * this._viewer.rotateClockwise(); */ rotateClockwise = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.rotateClockwise(tag); } return Promise.resolve(); }; /** * @method * @category Page * @desc Rotates all pages in the current document in counter-clockwise direction (by 90 degrees). * @returns {Promise&lt;void&gt;} * @example * this._viewer.rotateCounterClockwise(); */ rotateCounterClockwise = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.rotateCounterClockwise(tag); } return Promise.resolve(); }; /** * @method * @category Coordinate * @desc Converts points from screen coordinates to page coordinates in the viewer. * @param {object[]} points list of points, each in the format `{x: number, y: number}`. * You could optionally have a `pageNumber: number` in the object. * Without specifying, the page system is referring to the current page * @returns {Promise&lt;void | object[]&gt;} convertedPoints - list of converted points in page system, * each in the format `{x: number, y: number}`. It would be empty if conversion is unsuccessful * @example * // convert (50, 50) and (100, 100) from screen system to page system, * // on current page and page 1 respectively * this._viewer.convertScreenPointsToPagePoints([{x: 50, y: 50}, {x: 100, y:100, pageNumber: 1}]) * .then((convertedPoints) =&gt; { * convertedPoints.forEach(point =&gt; { * console.log(point); * }) * }); */ convertScreenPointsToPagePoints = (points) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.convertScreenPointsToPagePoints(tag, points); } return Promise.resolve(); }; /** * @method * @category Coordinate * @desc Converts points from page coordinates to screen coordinates in the viewer. * @param {object[]} points list of points, each in the format `{x: number, y: number}`. * You could optionally have a `pageNumber: number` in the object. * Without specifying, the page system is referring to the current page * @returns {Promise&lt;void | object[]&gt;} convertedPoints - list of converted points in * screen system, each in the format `{x: number, y: number}`. * It would be empty if conversion is unsuccessful * @example * // convert (50, 50) on current page and (100, 100) on page 1 from page system to screen system * this._viewer.convertPagePointsToScreenPoints([{x: 50, y: 50}, {x: 100, y:100, pageNumber: 1}]) * .then((convertedPoints) =&gt; { * convertedPoints.forEach(point =&gt; { * console.log(point); * }) * }); */ convertPagePointsToScreenPoints = (points) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.convertPagePointsToScreenPoints(tag, points); } return Promise.resolve(); }; /** * @method * @category Coordinate * @desc Returns the page number that contains the point on screen. * @param {number} x the x-coordinate of the screen point * @param {number} y the y-coordinate of the screen point * @returns {Promise&lt;void | number&gt;} pageNumber - the page number of the screen point * @example * this._viewer.getPageNumberFromScreenPoint(10.0,50.5).then((pageNumber) =&gt; { * console.log('The page number of the screen point is', pageNumber); * }); */ getPageNumberFromScreenPoint = (x, y) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getPageNumberFromScreenPoint(tag, x, y); } return Promise.resolve(); }; /** * @method * @category Rendering Options * @desc Sets whether the control will render progressively * or will just draw once the entire view has been rendered. * @param {boolean} progressiveRendering whether to render progressively * @param {number} initialDelay delay before the progressive rendering timer is started, * in milliseconds * @param {number} interval delay between refreshes, in milliseconds * @returns {Promise&lt;void&gt;} * @example * // delay for 10s before start, and refresh every 1s * this._viewer.setProgressiveRendering(true, 10000, 1000); */ setProgressiveRendering = (progressiveRendering, initialDelay, interval) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setProgressiveRendering(tag, progressiveRendering, initialDelay, interval); } return Promise.resolve(); }; /** * @method * @category Rendering Options * @desc Enables or disables image smoothing. * The rasterizer allows a trade-off between rendering quality and rendering speed. * This function can be used to indicate the preference between rendering speed and quality. * @param {boolean} imageSmoothing whether to enable image smoothing * @returns {Promise&lt;void&gt;} * @example * this._viewer.setImageSmoothing(false); */ setImageSmoothing = (imageSmoothing) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setImageSmoothing(tag, imageSmoothing); } return Promise.resolve(); }; /** * @method * @category Rendering Options * @desc Enables or disables support for overprint and overprint simulation. * Overprint is a device dependent feature and the results will vary depending * on the output color space and supported colorants (i.e. CMYK, CMYK+spot, RGB, etc). * @param {Config.OverprintMode} overprint the mode of overprint * @returns {Promise&lt;void&gt;} * @example * this._viewer.setOverprint(Config.OverprintMode.Off); */ setOverprint = (overprint) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setOverprint(tag, overprint); } return Promise.resolve(); }; /** * @method * @category UI Customization * @desc Sets the color post processing transformation mode for the viewer. * @param {Config.ColorPostProcessMode} colorPostProcessMode color post processing * transformation mode * @example * this._viewer.setColorPostProcessMode(Config.ColorPostProcessMode.NightMode); */ setColorPostProcessMode = (colorPostProcessMode) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setColorPostProcessMode(tag, colorPostProcessMode); } return Promise.resolve(); }; /** * @method * @category UI Customization * @desc Sets the white and black color for the color post processing transformation. * @param {object} whiteColor the white color for the color post processing transformation, * in the format `{red: number, green: number, blue: number}`. * `alpha` could be optionally included (only Android would apply alpha), * and all numbers should be in range [0, 255] * @param {object} blackColor the black color for the color post processing transformation, * in the same format as whiteColor * @example * const whiteColor = {\"red\": 0, \"green\": 0, \"blue\": 255}; * const blackColor = {\"red\": 255, \"green\": 0, \"blue\": 0}; * this._viewer.setColorPostProcessColors(whiteColor, blackColor); */ setColorPostProcessColors = (whiteColor, blackColor) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setColorPostProcessColors(tag, whiteColor, blackColor); } return Promise.resolve(); }; /** * @method * @category Text Selection * @desc Search for a term and all matching results will be highlighted. * @param {string} searchString the text to search for * @param {boolean} matchCase indicates if it is case sensitive * @param {boolean} matchWholeWord indicates if it matches an entire word only * @returns {Promise&lt;void&gt;} * @example * this._viewer.startSearchMode('PDFTron', false, false); */ startSearchMode = (searchString, matchCase, matchWholeWord) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.startSearchMode(tag, searchString, matchCase, matchWholeWord); } return Promise.resolve(); }; /** * @method * @category Text Selection * @desc Finishes the current text search and remove all the highlights. * @returns {Promise&lt;void&gt;} * @example * this._viewer.exitSearchMode(); */ exitSearchMode = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.exitSearchMode(tag); } return Promise.resolve(); }; /** * @method * @category Text Selection * @desc Searches asynchronously, starting from the current page, for the given text. * PDFViewCtrl automatically scrolls to the position so that the found text is visible. * @param {string} searchString the text to search for * @param {boolean} matchCase indicates if it is case sensitive * @param {boolean} matchWholeWord indicates if it matches an entire word only * @param {boolean} searchUp indicates if it searches upward * @param {boolean} regExp indicates if searchString is a regular expression * @returns {Promise&lt;void&gt;} * @example * this._viewer.findText('PDFTron', false, false, true, false); */ findText = (searchString, matchCase, matchWholeWord, searchUp, regExp) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.findText(tag, searchString, matchCase, matchWholeWord, searchUp, regExp); } return Promise.resolve(); }; /** * @method * @category Text Selection * @desc Cancels the current text search thread, if exists. * @returns {Promise&lt;void&gt;} * @example * this._viewer.cancelFindText(); */ cancelFindText = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.cancelFindText(tag); } return Promise.resolve(); }; /** * @method * @category Text Selection * @desc Displays a search bar that allows the user to enter and search text within a document. * @returns {Promise&lt;void&gt;} * @example * this._viewer.openSearch(); */ openSearch = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.openSearch(tag); } return Promise.resolve(); }; /** * @method * @category Text Selection * @desc Returns the text selection on a given page, if any. * @param {number} pageNumber the specified page number. It is 1-indexed * @returns {Promise&lt;void | object&gt;} selection - the text selection, in the format * `{html: string, unicode: string, pageNumber: number, * quads: [[{x: number, y: number}, {x: number, y: number}, * {x: number, y: number}, {x: number, y: number}], ...]}`. * If no such selection could be found, this would be null * * Quads indicate the quad boundary boxes for the selection, * which could have a size larger than 1 if selection spans across different lines. * Each quad have 4 points with x, y coordinates specified in number, representing a boundary box. * The 4 points are in counter-clockwise order, though the first point is not guaranteed to be on * lower-left relatively to the box. * @example * this._viewer.getSelection(2).then((selection) =&gt; { * if (selection) { * console.log('Found selection on page', selection.pageNumber); * for (let i = 0; i &lt; selection.quads.length; i ++) { * const quad = selection.quads[i]; * console.log('selection boundary quad', i); * for (const quadPoint of quad) { * console.log('A quad point has coordinates', quadPoint.x, quadPoint.y); * } * } * } * }); */ getSelection = (pageNumber) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getSelection(tag, pageNumber); } return Promise.resolve(); }; /** * @method * @category Text Selection * @desc Returns whether there is a text selection in the current document. * @returns {Promise&lt;void | boolean&gt;} hasSelection - whether a text selection exists * @example * this._viewer.hasSelection().then((hasSelection) =&gt; { * console.log('There is a selection in the document.'); * }); */ hasSelection = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.hasSelection(tag); } return Promise.resolve(); }; /** * @method * @category Text Selection * @desc Clears any text selection in the current document. * @returns {Promise&lt;void&gt;} * @example * this._viewer.clearSelection(); */ clearSelection = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.clearSelection(tag); } return Promise.resolve(); }; /** * @method * @category Text Selection * @desc Returns the page range (beginning and end) that has text selection on it. * @returns {Promise&lt;void | object&gt;} * * Name | Type | Description * --- | --- | --- * begin | number | the first page to have selection, -1 if there are no selections * end | number | the last page to have selection, -1 if there are no selections * * @example * this._viewer.getSelectionPageRange().then(({begin, end}) =&gt; { * if (begin === -1) { * console.log('There is no selection'); * } else { * console.log('The selection range is from', begin, 'to', end); * } * }); */ getSelectionPageRange = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getSelectionPageRange(tag); } return Promise.resolve(); }; /** * @method * @category Text Selection * @desc Returns whether there is a text selection on the specified page in the current document. * @param {number} pageNumber the specified page number. It is 1-indexed * @returns {Promise&lt;void | boolean&gt;} hasSelection - whether a text selection exists on * the specified page * @example * this._viewer.hasSelectionOnPage(5).then((hasSelection) =&gt; { * if (hasSelection) { * console.log('There is a selection on page 5 in the document.'); * } * }); */ hasSelectionOnPage = (pageNumber) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.hasSelectionOnPage(tag, pageNumber); } return Promise.resolve(); }; /** * @method * @category Text Selection * @desc Selects the text within the given rectangle region. * @param {object} rect the rectangle region in the format of * `{x1: number, x2: number, y1: number, y2: number}` * @returns {Promise&lt;void | boolean&gt;} selected - whether there is text selected * @example * this._viewer.selectInRect({x1: 0, y1: 0, x2: 200.5, y2: 200.5}).then((selected) =&gt; { * console.log(selected); * }); */ selectInRect = (rect) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.selectInRect(tag, rect); } return Promise.resolve(); }; /** * @method * @category Text Selection * @desc Returns whether there is text in given rectangle region. * @param {object} rect the rectangle region in the format of * `{x1: number, x2: number, y1: number, y2: number}` * @returns {Promise&lt;void | boolean&gt;} hasText - whether there is text in the region * @example * this._viewer.isThereTextInRect({x1: 0, y1: 0, x2: 200, y2: 200}).then((hasText) =&gt; { * console.log(hasText); * }); */ isThereTextInRect = (rect) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.isThereTextInRect(tag, rect); } return Promise.resolve(); }; /** * @method * @category Text Selection * @desc Selects all text on the page. * @returns {Promise&lt;void&gt;} * @example * this._viewer.selectAll(); */ selectAll = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.selectAll(tag); } return Promise.resolve(); }; /** * @method * @category Viewer Options * @desc Sets whether borders of each page are visible in the viewer, * which is disabled by default. * @param {boolean} pageBorderVisibility whether borders of each page are visible in the viewer * @example * this._viewer.setPageBorderVisibility(true); */ setPageBorderVisibility = (pageBorderVisibility) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setPageBorderVisibility(tag, pageBorderVisibility); } return Promise.resolve(); }; /** * @method * @category Viewer Options * @desc Enables or disables transparency grid (check board pattern) to reflect page transparency, * which is disabled by default. * @param {boolean} pageTransparencyGrid whether to use the transparency grid * @example * this._viewer.setPageTransparencyGrid(true); */ setPageTransparencyGrid = (pageTransparencyGrid) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setPageTransparencyGrid(tag, pageTransparencyGrid); } return Promise.resolve(); }; /** * @method * @category Viewer Options * @desc Sets the default page color of the viewer. * @param {object} defaultPageColor the default page color, in the format * `{red: number, green: number, blue: number}`, each number in range [0, 255] * @example * this._viewer.setDefaultPageColor({red: 0, green: 255, blue: 0}); // green color */ setDefaultPageColor = (defaultPageColor) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setDefaultPageColor(tag, defaultPageColor); } return Promise.resolve(); }; /** * @method * @category Viewer Options * @desc Sets the background color of the viewer. * @param {object} backgroundColor the background color, in the format * `{red: number, green: number, blue: number}`, each number in range [0, 255] * @example * this._viewer.setBackgroundColor({red: 0, green: 0, blue: 255}); // blue color */ setBackgroundColor = (backgroundColor) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setBackgroundColor(tag, backgroundColor); } return Promise.resolve(); }; /** * @method * @desc Export a PDF page to image format defined in {@link Config.ExportFormat}. * * Unlike {@link RNPdftron#exportAsImage RNPdftron.exportAsImage}, * this is a viewer method and should only be called *after* the document has been * loaded or else unexpected behaviour can occur. * This method uses the PDF that is associated with the viewer, * and does not take a local file path to the desired PDF. * @param {int} pageNumber the page to be converted; * if the value does not refer to a valid page number, the file path will be undefined * @param {double} dpi the output image resolution * @param {Config.ExportFormat} exportFormat image format to be exported to * @returns {Promise&lt;void | string&gt;} path - the temp path of the created image, * user is responsible for clean up the cache * @example * this._viewer.exportToImage(1, 92, Config.ExportFormat.BMP).then((path) =&gt; { * console.log('export', path); * }); */ exportAsImage = (pageNumber, dpi, exportFormat) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.exportAsImage(tag, pageNumber, dpi, exportFormat); } return Promise.resolve(); }; /** * @method * @category Undo/Redo * @desc Undo the last modification. * @returns {Promise&lt;void&gt;} * @example * this._viewer.undo(); */ undo = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.undo(tag); } return Promise.resolve(); }; /** * @method * @category Undo/Redo * @desc Redo the last modification. * @returns {Promise&lt;void&gt;} * @example * this._viewer.redo(); */ redo = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.redo(tag); } return Promise.resolve(); }; /** * @method * @category Undo/Redo * @desc Checks whether an undo operation can be performed from the current snapshot. * @returns {Promise&lt;void | boolean&gt;} canUndo - whether it is possible to undo from * the current snapshot * @example * this._viewer.canUndo().then((canUndo) =&gt; { * console.log(canUndo ? 'undo possible' : 'no action to undo'); * }); */ canUndo = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.canUndo(tag); } return Promise.resolve(); }; /** * @method * @category Undo/Redo * @desc Checks whether a redo operation can be perfromed from the current snapshot. * @returns {Promise&lt;void | boolean&gt;} canRedo - whether it is possible to redo from * the current snapshot * @example * this._viewer.canRedo().then((canRedo) =&gt; { * console.log(canRedo ? 'redo possible' : 'no action to redo'); * }); */ canRedo = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.canRedo(tag); } return Promise.resolve(); }; /** * @method * @desc Displays the page crop option. Android only. * @returns {Promise&lt;void&gt;} * @example * this._viewer.showCrop(); */ showCrop = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.showCrop(tag); } return Promise.resolve(); }; /** * @method * @category Toolbar * @desc Sets the current {@link DocumentView.annotationToolbars annotationToolbars} * for the viewer. * @param {Config.DefaultToolbars|string} toolbar the toolbar to enable. Should be one of the * {@link Config.DefaultToolbars} constants or the `id` of a custom toolbar object. * @returns {Promise&lt;void&gt;} * @example * this._viewer.setCurrentToolbar(Config.DefaultToolbars.Insert).then(() =&gt; { * // done switching toolbar * }); */ setCurrentToolbar = (toolbar) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.setCurrentToolbar(tag, toolbar); } return Promise.resolve(); }; /** * @method * @desc Displays the view settings. * * Requires a source rect in screen co-ordinates. * On iOS this rect will be the anchor point for the view. The rect is ignored on Android. * @param {map} rect The rectangular area in screen co-ordinates with keys * `x1` (left), `y1` (bottom), `y1` (right), `y2` (top). Coordinates are in double format. * @returns {Promise&lt;void&gt;} * @example * this._viewer.showViewSettings({'x1': 10.0, 'y1': 10.0, 'x2': 20.0, 'y2': 20.0}); */ showViewSettings = (rect) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.showViewSettings(tag, rect); } return Promise.resolve(); }; /** * @method * @category Page * @desc Android only. * * Displays a rotate dialog. * This dialog allows users to rotate pages of the opened document by 90, 180 and 270 degrees. * It also displays a thumbnail of the current page at the selected rotation angle. * @returns {Promise&lt;void&gt;} * @example * this._viewer.showRotateDialog(); */ showRotateDialog = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.showRotateDialog(tag); } return Promise.resolve(); }; /** * @method * @desc Displays the add pages view. * * Requires a source rect in screen co-ordinates. * On iOS this rect will be the anchor point for the view. The rect is ignored on Android. * @param {map} rect The rectangular area in screen co-ordinates with keys * `x1` (left), `y1` (bottom), `y1` (right), `y2`(top). Coordinates are in double format. * @returns {Promise&lt;void&gt;} * @example * this._viewer.showAddPagesView({'x1': 10.0, 'y1': 10.0, 'x2': 20.0, 'y2': 20.0}); */ showAddPagesView = (rect) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.showAddPagesView(tag, rect); } return Promise.resolve(); }; /** * @method * @category Reflow * @desc Returns whether the viewer is currently in reflow mode. * @returns {Promise&lt;void | boolean&gt;} inReflow - whether the viewer is in reflow mode * @example * this._viewer.isReflowMode().then((inReflow) =&gt; { * console.log(inReflow ? 'in reflow mode' : 'not in reflow mode'); * }); */ isReflowMode = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.isReflowMode(tag); } return Promise.resolve(); }; /** * @method * @category Reflow * @desc Allows the user to programmatically enter and exit reflow mode. * @returns {Promise&lt;void&gt;} * @example * this._viewer.toggleReflow(); */ toggleReflow = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.toggleReflow(tag); } return Promise.resolve(); }; /** * @method * @desc Displays the share copy view. * * Requires a source rect in screen co-ordinates. * On iOS this rect will be the anchor point for the view. The rect is ignored on Android. * @returns {Promise&lt;void&gt;} * @param {map} rect The rectangular area in screen co-ordinates with keys * `x1` (left), y1 (bottom), `y1` (right), `y2` (top). Coordinates are in double format. * @param {boolean} flattening Whether the shared copy should be flattened before sharing. * @example * this._viewer.shareCopy({'x1': 10.0, 'y1': 10.0, 'x2': 20.0, 'y2': 20.0}, true); */ shareCopy = (rect, flattening) =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.shareCopy(tag, rect, flattening); } return Promise.resolve(); }; /** * @method * @category Thumbnails * @desc Display a page thumbnails view. * * This view allows users to navigate pages of a document. * If {@link DocumentView.thumbnailViewEditingEnabled thumbnailViewEditingEnabled} is true, * the user can also manipulate the document, including add, remove, re-arrange, rotate and * duplicate pages. * @returns {Promise&lt;void&gt;} * @example * this._viewer.openThumbnailsView(); */ openThumbnailsView = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.openThumbnailsView(tag); } return Promise.resolve(); }; /** * @method * @desc Displays the outline tab of the existing list container. * If this tab has been disabled, the method does nothing. * @returns {Promise&lt;void&gt;} * @example * this._viewer.openOutlineList(); */ openOutlineList = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.openOutlineList(tag); } return Promise.resolve(); }; /** * @method * @desc On Android it displays the layers dialog, while on iOS it displays the layers tab * of the existing list container. If this tab has been disabled or there are no layers in * the document, the method does nothing. * @returns {Promise&lt;void&gt;} * @example * this._viewer.openLayersList(); */ openLayersList = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.openLayersList(tag); } return Promise.resolve(); }; /** * @method * @desc Displays the existing list container. Its current tab will be the one last opened. * @returns {Promise&lt;void&gt;} * @example * this._viewer.openNavigationLists(); */ openNavigationLists = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.openNavigationLists(tag); } return Promise.resolve(); }; /** * @method * @category Signature * @desc Gets a list of absolute file paths to PDFs containing the saved signatures. * @returns {Promise&lt;void | Array&lt;string&gt;&gt;} signatures - an array of string containing the * absolute file paths; if there are no saved signatures, the value is an empty array * @example * this._viewer.getSavedSignatures().then((signatures) =&gt; { * if (signatures.length &gt; 0) { * signatures.forEach((signature) =&gt; { * console.log(signature); * }); * } * }) */ getSavedSignatures = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getSavedSignatures(tag); } return Promise.resolve(); }; /** * @method * @category Signature * @desc Retrieves the absolute file path to the folder containing the saved signatures. * For Android, to get the folder containing the saved signature JPGs, use * {@link DocumentView.getSavedSignatureJpgFolder getSavedSignatureJpgFolder}. * @returns {Promise&lt;void | string&gt;} path - the absolute file path to the folder * @example * this._viewer.getSavedSignatureFolder().then((path) =&gt; { * if (path != null) { * console.log(path); * } * }) */ getSavedSignatureFolder = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getSavedSignatureFolder(tag); } return Promise.resolve(); }; /** * @method * @category Signature * @desc Android only. * * Retrieves the absolute file path to the folder containing the saved signature JPGs. * For Android, to get the folder containing the saved signature PDFs, use * {@link DocumentView.getSavedSignatureFolder getSavedSignatureFolder}. * @returns {Promise&lt;void | string&gt;} path - the absolute file path to the folder * @example * this._viewer.getSavedSignatureJpgFolder().then((path) =&gt; { * if (path != null) { * console.log(path); * } * }) */ getSavedSignatureJpgFolder = () =&gt; { const tag = findNodeHandle(this._viewerRef); if (tag != null) { return DocumentViewManager.getSavedSignatureJpgFolder(tag); } return Promise.resolve(); }; /** @ignore */ _setNativeRef = (ref) =&gt; { this._viewerRef = ref; }; /** * @ignore * */ render() { return ( // @ts-ignore &lt;RCTDocumentView ref={this._setNativeRef} // @ts-ignore style={{ flex: 1 }} // @ts-ignore: Intentionally exclude `onChange` from being exposed as a prop. onChange={this.onChange} {...this.props}/&gt;); } } const name = Platform.OS === 'ios' ? 'RNTPTDocumentView' : 'RCTDocumentView'; const RCTDocumentView = requireNativeComponent(name);  Search results Close Documentation generated by JSDoc 3.6.7 on 2021-10-04T11:23:32-07:00 using the DocStrap template. "},"lib_src_Config_Config.js.html":{"id":"lib_src_Config_Config.js.html","title":"Source: lib/src/Config/Config.js","body":" PDFTron React Native Classes ConfigDocumentViewPDFViewCtrlRNPdftron Events onAnnotationMenuPressonAnnotationsSelectedonAnnotationChangedonFormFieldValueChangedonBookmarkChangedonBehaviorActivatedonExportAnnotationCommandonLayoutChangedonLongPressMenuPressonTabChangedonDocumentLoadedonDocumentErroronPageChangedonPageMovedonScrollChangedonTextSearchStartonTextSearchResultonLeadingNavButtonPressedonToolChangedonUndoRedoStateChangedonZoomChangedonZoomFinished Source: lib/src/Config/Config.js /** * @constant * @class (Assigned to class for documentation purposes.) * @hideconstructor * @name Config * @classdesc Defines configuration constants for the viewer. * See [`Config.ts`](https://github.com/PDFTron/pdftron-react-native/blob/master/src/Config/Config.js) * for the full list of constants. * * Due to the length of the source file, we have included links to the exact lines * of the source code where these APIs have been implemented. */ export const Config = { /** * @member * @desc Buttons define the various kinds of buttons for the viewer */ Buttons: { editToolButton: 'editToolButton', viewControlsButton: 'viewControlsButton', freeHandToolButton: 'freeHandToolButton', highlightToolButton: 'highlightToolButton', underlineToolButton: 'underlineToolButton', squigglyToolButton: 'squigglyToolButton', strikeoutToolButton: 'strikeoutToolButton', rectangleToolButton: 'rectangleToolButton', ellipseToolButton: 'ellipseToolButton', lineToolButton: 'lineToolButton', arrowToolButton: 'arrowToolButton', polylineToolButton: 'polylineToolButton', polygonToolButton: 'polygonToolButton', cloudToolButton: 'cloudToolButton', signatureToolButton: 'signatureToolButton', freeTextToolButton: 'freeTextToolButton', stickyToolButton: 'stickyToolButton', calloutToolButton: 'calloutToolButton', stampToolButton: 'stampToolButton', toolsButton: 'toolsButton', searchButton: 'searchButton', shareButton: 'shareButton', editPagesButton: 'editPagesButton', viewLayersButton: 'viewLayersButton', printButton: 'printButton', closeButton: 'closeButton', saveCopyButton: 'saveCopyButton', saveIdenticalCopyButton: 'saveIdenticalCopyButton', saveFlattenedCopyButton: 'saveFlattenedCopyButton', formToolsButton: 'formToolsButton', fillSignToolsButton: 'fillSignToolsButton', moreItemsButton: 'moreItemsButton', digitalSignatureButton: 'digitalSignatureButton', thumbnailsButton: 'thumbnailsButton', listsButton: 'listsButton', thumbnailSlider: 'thumbnailSlider', outlineListButton: 'outlineListButton', annotationListButton: 'annotationListButton', userBookmarkListButton: 'userBookmarkListButton', reflowButton: 'reflowButton', editMenuButton: 'editMenuButton', cropPageButton: 'cropPageButton', undo: 'undo', redo: 'redo', addPageButton: 'addPageButton', // Android only saveReducedCopyButton: 'saveReducedCopyButton', saveCroppedCopyButton: 'saveCroppedCopyButton', savePasswordCopyButton: 'savePasswordCopyButton' }, /** * @member * @desc Tools define the various kinds of tools for the viewer */ Tools: { annotationEdit: 'AnnotationEdit', textSelect: 'TextSelect', pan: 'Pan', annotationEraserTool: 'AnnotationEraserTool', annotationCreateSticky: 'AnnotationCreateSticky', annotationCreateFreeHand: 'AnnotationCreateFreeHand', annotationCreateTextHighlight: 'AnnotationCreateTextHighlight', annotationCreateTextUnderline: 'AnnotationCreateTextUnderline', annotationCreateTextSquiggly: 'AnnotationCreateTextSquiggly', annotationCreateTextStrikeout: 'AnnotationCreateTextStrikeout', annotationCreateFreeText: 'AnnotationCreateFreeText', annotationCreateCallout: 'AnnotationCreateCallout', annotationCreateSignature: 'AnnotationCreateSignature', annotationCreateLine: 'AnnotationCreateLine', annotationCreateArrow: 'AnnotationCreateArrow', annotationCreatePolyline: 'AnnotationCreatePolyline', annotationCreateStamp: 'AnnotationCreateStamp', annotationCreateRubberStamp: 'AnnotationCreateRubberStamp', annotationCreateRectangle: 'AnnotationCreateRectangle', annotationCreateEllipse: 'AnnotationCreateEllipse', annotationCreatePolygon: 'AnnotationCreatePolygon', annotationCreatePolygonCloud: 'AnnotationCreatePolygonCloud', annotationCreateDistanceMeasurement: 'AnnotationCreateDistanceMeasurement', annotationCreatePerimeterMeasurement: 'AnnotationCreatePerimeterMeasurement', annotationCreateAreaMeasurement: 'AnnotationCreateAreaMeasurement', annotationCreateFileAttachment: 'AnnotationCreateFileAttachment', annotationCreateSound: 'AnnotationCreateSound', annotationCreateRedaction: 'AnnotationCreateRedaction', annotationCreateLink: 'AnnotationCreateLink', annotationCreateRedactionText: 'AnnotationCreateRedactionText', annotationCreateLinkText: 'AnnotationCreateLinkText', annotationCreateFreeHighlighter: 'AnnotationCreateFreeHighlighter', formCreateTextField: 'FormCreateTextField', formCreateCheckboxField: 'FormCreateCheckboxField', formCreateSignatureField: 'FormCreateSignatureField', formCreateRadioField: 'FormCreateRadioField', formCreateComboBoxField: 'FormCreateComboBoxField', formCreateListBoxField: 'FormCreateListBoxField', // iOS only. pencilKitDrawing: 'PencilKitDrawing' }, /** * @member * @desc FitMode define how a page should fit relative to the viewer, * alternatively, the default zoom level */ FitMode: { FitPage: 'FitPage', FitWidth: 'FitWidth', FitHeight: 'FitHeight', Zoom: 'Zoom' }, /** * @member * @desc LayoutMode defines the layout mode of the viewer */ LayoutMode: { Single: 'Single', Continuous: 'Continuous', Facing: 'Facing', FacingContinuous: 'FacingContinuous', FacingCover: 'FacingCover', FacingCoverContinuous: 'FacingCoverContinuous' }, /** * @member * @desc FieldFlags define the property flags for a form field */ FieldFlags: { ReadOnly: 0, Required: 1 }, /** * @member * @desc AnnotationMenu defines the menu items when an annotation is selected */ AnnotationMenu: { style: 'style', note: 'note', copy: 'copy', duplicate: 'duplicate', delete: 'delete', flatten: 'flatten', editText: 'editText', editInk: 'editInk', search: 'search', share: 'share', markupType: 'markupType', read: 'read', screenCapture: 'screenCapture', playSound: 'playSound', openAttachment: 'openAttachment', calibrate: 'calibrate' }, /** * @member * @desc EraserType defines the type of eraser that will be used when eraser is selected */ EraserType: { annotationEraser: 'annotationEraser', hybrideEraser: 'hybrideEraser', inkEraser: 'inkEraser' }, /** * @member * @desc LongPressMenu defines the menu items when a long press on empty space or text occurs */ LongPressMenu: { copy: 'copy', paste: 'paste', search: 'search', share: 'share', read: 'read' }, /** * @member * @desc Actions define potentially overridable action to the viewer */ Actions: { linkPress: 'linkPress', stickyNoteShowPopUp: 'stickyNoteShowPopUp' }, /** * @member * @desc AnnotationFlags define the flags for any annotation in the document */ AnnotationFlags: { hidden: \"hidden\", invisible: \"invisible\", locked: \"locked\", lockedContents: \"lockedContents\", noRotate: \"noRotate\", noView: \"noView\", noZoom: \"noZoom\", print: \"print\", readOnly: \"readOnly\", toggleNoView: \"toggleNoView\" }, /** * @member * @desc DefaultToolbars define a set of pre-designed toolbars for easier customization */ DefaultToolbars: { View: \"PDFTron_View\", Annotate: \"PDFTron_Annotate\", Draw: \"PDFTron_Draw\", Insert: \"PDFTron_Insert\", FillAndSign: \"PDFTron_Fill_and_Sign\", PrepareForm: \"PDFTron_Prepare_Form\", Measure: \"PDFTron_Measure\", Pens: \"PDFTron_Pens\", Redaction: \"PDFTron_Redact\", Favorite: \"PDFTron_Favorite\" }, /** * @member * @desc ToolbarIcons define default toolbar icons for use for potential custom toolbars */ ToolbarIcons: { View: \"PDFTron_View\", Annotate: \"PDFTron_Annotate\", Draw: \"PDFTron_Draw\", Insert: \"PDFTron_Insert\", FillAndSign: \"PDFTron_Fill_and_Sign\", PrepareForm: \"PDFTron_Prepare_Form\", Measure: \"PDFTron_Measure\", Pens: \"PDFTron_Pens\", Redaction: \"PDFTron_Redact\", Favorite: \"PDFTron_Favorite\" }, /** * @member * @desc CustomToolbarKey defines the necessary keys for a custom toolbar */ CustomToolbarKey: { Id: \"id\", Name: \"name\", Icon: \"icon\", Items: \"items\" }, /** * @member * @desc ThumbnailFilterMode defines filter modes in the thumbnails browser */ ThumbnailFilterMode: { Annotated: \"annotated\", Bookmarked: \"bookmarked\" }, /** * @member * @desc Conversion defines conversion sources and destinations */ Conversion: { Screen: \"screen\", Canvas: \"canvas\", Page: \"page\" }, /** * @member * @desc ViewModePickerItem defines view mode items in the view mode dialog */ ViewModePickerItem: { Crop: \"viewModeCrop\", Rotation: \"viewModeRotation\", ColorMode: \"viewModeColorMode\" }, /** * @member * @desc ZoomLimitMode defines the limit mode for zoom in the current document viewer */ ZoomLimitMode: { None: \"none\", Absolute: \"absolute\", Relative: \"relative\" }, /** * @member * @desc OverprintMode defines when overprint would be applied in the viewer */ OverprintMode: { On: \"on\", Off: \"off\", OnlyPDFX: \"pdfx\" // only apply to PDF/X files }, /** * @member * @desc ColorPostProcessMode defines color modifications after rendering in the viewer */ ColorPostProcessMode: { None: \"none\", Invert: \"invert\", GradientMap: \"gradientMap\", NightMode: \"nightMode\" }, /** * @member * @desc ReflowOrientation defines the scrolling direction when in reflow viewing mode */ ReflowOrientation: { Horizontal: 'horizontal', Vertical: 'vertical' }, /** * @member * @desc Export to format */ ExportFormat: { BMP: \"BMP\", JPEG: \"JPEG\", PNG: \"PNG\" } };  Search results Close Documentation generated by JSDoc 3.6.7 on 2021-10-04T11:23:33-07:00 using the DocStrap template. "},"lib_src_PDFViewCtrl_PDFViewCtrl.js.html":{"id":"lib_src_PDFViewCtrl_PDFViewCtrl.js.html","title":"Source: lib/src/PDFViewCtrl/PDFViewCtrl.js","body":" PDFTron React Native Classes ConfigDocumentViewPDFViewCtrlRNPdftron Events onAnnotationMenuPressonAnnotationsSelectedonAnnotationChangedonFormFieldValueChangedonBookmarkChangedonBehaviorActivatedonExportAnnotationCommandonLayoutChangedonLongPressMenuPressonTabChangedonDocumentLoadedonDocumentErroronPageChangedonPageMovedonScrollChangedonTextSearchStartonTextSearchResultonLeadingNavButtonPressedonToolChangedonUndoRedoStateChangedonZoomChangedonZoomFinished Source: lib/src/PDFViewCtrl/PDFViewCtrl.js import React, { PureComponent } from 'react'; import PropTypes from 'prop-types'; import { requireNativeComponent, ViewPropTypes, Platform } from 'react-native'; /** * @desc This object outlines valid {@link PDFViewCtrl} class props. * These can be passed into {@link PDFViewCtrl} to customize the viewer. * @ignore */ const PDFViewCtrlPropTypes = { /** * @memberof PDFViewCtrl * @type {string} * @desc The path or url to the document. Required. * @hidesource * @example * &lt;PDFViewCtrl * document={'https://pdftron.s3.amazonaws.com/downloads/pl/PDFTRON_about.pdf'} * /&gt; */ document: PropTypes.string.isRequired }; /** * @class * @classdesc A React component for displaying documents of different types such as * PDF, docx, pptx, xlsx and various image formats. * * PDFViewCtrl is useful when a higher level of customization is required. * For easy all-in-one document viewing and editing, use {@link DocumentView}. * @hideconstructor * @hidesource */ export class PDFViewCtrl extends PureComponent { static propTypes = Object.assign(PDFViewCtrlPropTypes, { ...ViewPropTypes }); render() { return (&lt;RCTPDFViewCtrl // @ts-ignore style={{ flex: 1 }} {...this.props}/&gt;); } } const name = Platform.OS === 'ios' ? 'RNTPTPDFViewCtrl' : 'RCTPDFViewCtrl'; const RCTPDFViewCtrl = requireNativeComponent(name);  Search results Close Documentation generated by JSDoc 3.6.7 on 2021-10-04T11:23:33-07:00 using the DocStrap template. "},"index.ts.html":{"id":"index.ts.html","title":"Source: index.ts","body":" PDFTron React Native Classes ConfigDocumentViewPDFViewCtrlRNPdftron Events onAnnotationMenuPressonAnnotationsSelectedonAnnotationChangedonFormFieldValueChangedonBookmarkChangedonBehaviorActivatedonExportAnnotationCommandonLayoutChangedonLongPressMenuPressonTabChangedonDocumentLoadedonDocumentErroronPageChangedonPageMovedonScrollChangedonTextSearchStartonTextSearchResultonLeadingNavButtonPressedonToolChangedonUndoRedoStateChangedonZoomChangedonZoomFinished Source: index.ts import { NativeModules } from 'react-native'; import { PDFViewCtrl } from './src/PDFViewCtrl/PDFViewCtrl'; import { DocumentView } from './src/DocumentView/DocumentView'; import { Config } from './src/Config/Config'; import * as AnnotOptions from './src/AnnotOptions/AnnotOptions'; /** * @typedef RNPdftron * @hidesource * @desc RNPdftron contains static methods for global library initialization, configuration, and * utility methods. */ interface RNPdftron { /** * @method * @desc Initializes PDFTron SDK with your PDFTron commercial license key. * You can run PDFTron in demo mode by passing an empty string. * @param {string} licenseKey your PDFTron license key * @example RNPdftron.initialize('your_license_key'); */ initialize(licenseKey: string) : void; /** * @method * @desc Enables JavaScript engine for PDFTron SDK, by default it is enabled. * @param {boolean} enabled whether to enable or disable JavaScript engine * @example RNPdftron.enableJavaScript(true); */ enableJavaScript(enabled: boolean) : void; /** * @method * @desc Gets the current PDFNet version. * @returns {Promise&lt;string&gt;} version - current PDFNet version * @example * RNPdftron.getVersion().then((version) =&gt; { * console.log(\"Current PDFNet version:\", version); * }); */ getVersion() : Promise&lt;string&gt;; /** * @method * @desc Gets the version of current platform (Android/iOS). * @returns {Promise&lt;string&gt;} platformVersion - current platform version (Android/iOS) * @example * RNPdftron.getPlatformVersion().then((platformVersion) =&gt; { * console.log(\"App currently running on:\", platformVersion); * }); */ getPlatformVersion() : Promise&lt;string&gt;; /** * @method * @desc Gets the font list available on the OS (Android only). * This is typically useful when you are mostly working with non-ascii characters in the viewer. * @returns {Promise&lt;string&gt;} fontList - the font list available on Android * @example * RNPdftron.getSystemFontList().then((fontList) =&gt; { * console.log(\"OS font list:\", fontList); * }); */ getSystemFontList() : Promise&lt;string&gt;; /** * @method * @desc Clear the information and bitmap cache for rubber stamps (Android only). * This is typically useful when the content of rubber stamps has been changed in the viewer. * @example * RNPdftron.clearRubberStampCache().then(() =&gt; { * console.log(\"Rubber stamp cache cleared\"); * }); */ clearRubberStampCache() : Promise&lt;void&gt;; /** * @method * @desc Encrypts (password-protect) a document (must be a PDF). * * **Note**: This function does not lock the document, * it cannot be used while the document is opened in the viewer. * @param {string} filePath the local file path to the file * @param {string} password the password you would like to set * @param {string} currentPassword the current password, use empty string if no password * @example * RNPdftron.encryptDocument(\"/sdcard/Download/new.pdf\", \"1111\", \"\").then(() =&gt; { * console.log(\"done password\"); * }); */ encryptDocument(filePath: string, password: string, currentPassword: string) : Promise&lt;void&gt;; /** * @method * @desc Generates a PDF using a template in the form of an Office document * and replacement data in the form of a JSON object. * For more information please see our * [template guide](https://www.pdftron.com/documentation/core/guides/generate-via-template/). * * The user is responsible for cleaning up the temporary file that is generated. * @param {string} docxPath the local file path to the template file * @param {object} json the replacement data in the form of a JSON object * @returns {Promise&lt;string&gt;} resultPdfPath - the local file path to the generated PDF * @example * RNPdftron.pdfFromOfficeTemplate(\"/sdcard/Download/red.docx\", json).then((resultPdfPath) =&gt; { * console.log(resultPdfPath); * }); */ pdfFromOfficeTemplate(docxPath: string, json: object) : Promise&lt;string&gt;; /** * @method * @desc Export a PDF page to an image format defined in {@link Config.ExportFormat}. * * Unlike {@link DocumentView#exportAsImage DocumentView.exportAsImage}, * this method is static and should only be called *before* a `DocumentView` * instance has been created or else unexpected behaviour can occur. * This method also takes a local file path to the desired PDF. * @param {int} pageNumber the page to be converted; * if the value does not refer to a valid page number, the file path will be undefined * @param {double} dpi the output image resolution * @param {Config.ExportFormat} exportFormat image format to be exported to * @param {string} filePath local file path to pdf * @returns {Promise&lt;string&gt;} resultImagePath - the temp path of the created image, * user is responsible for clean up the cache * @example * RNPdftron.exportAsImage(1, 92, Config.ExportFormat.BMP, \"/sdcard/Download/red.pdf\").then( * (resultImagePath) =&gt; { * console.log('export', resultImagePath); * }); */ exportAsImage(pageNumber: number, dpi: number, exportFormat: Config.ExportFormat, filePath: string) : Promise&lt;string&gt;; } /** * @class * @hideconstructor */ // eslint-disable-next-line no-redeclare const RNPdftron : RNPdftron = NativeModules.RNPdftron; export { RNPdftron, PDFViewCtrl, DocumentView, Config, AnnotOptions };  Search results Close Documentation generated by JSDoc 3.6.7 on 2021-10-04T11:23:33-07:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" PDFTron React Native Classes ConfigDocumentViewPDFViewCtrlRNPdftron Events onAnnotationMenuPressonAnnotationsSelectedonAnnotationChangedonFormFieldValueChangedonBookmarkChangedonBehaviorActivatedonExportAnnotationCommandonLayoutChangedonLongPressMenuPressonTabChangedonDocumentLoadedonDocumentErroronPageChangedonPageMovedonScrollChangedonTextSearchStartonTextSearchResultonLeadingNavButtonPressedonToolChangedonUndoRedoStateChangedonZoomChangedonZoomFinished Classes Config DocumentView PDFViewCtrl RNPdftron Events Annotation Menu onAnnotationMenuPress This function is called when an annotation menu item passed in to overrideAnnotationMenuBehavior is pressed. Type: function Optional. Source: DocumentView.js line 421 Parameters: Name Type Description annotationMenu Config.AnnotationMenu the menu item that has been pressed. annotations Array&lt;object&gt; An array of {id: string, pageNumber: number, type: string, screenRect: object, pageRect: object} objects. id is the annotation identifier and type is one of the Config.Tools constants. screenRect was formerly called rect. Both rects are represented with {x1: number, y1: number, x2: number, y2: number, width: number, height: number} objects. Example &lt;DocumentView onAnnotationMenuPress = {({annotationMenu, annotations}) =&gt; { console.log('Annotation menu item', annotationMenu, 'has been pressed'); annotations.forEach(annotation =&gt; { console.log('The id of selected annotation is', annotation.id); console.log('The page number of selected annotation is', annotation.pageNumber); console.log('The type of selected annotation is', annotation.type); console.log('The screenRect of selected annotation is', annotation.screenRect); console.log('The pageRect of selected annotation is', annotation.pageRect); }); }} /&gt; Annotations onAnnotationsSelected This function is called when an annotation(s) is selected. Type: function Optional. Source: DocumentView.js line 589 Parameters: Name Type Description annotations Array&lt;object&gt; array of annotation data in the format {id: string, pageNumber: number, type: string, screenRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}, pageRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}}, representing the selected annotations. type is one of the Config.Tools constants. screenRect was formerly called rect. Example &lt;DocumentView onAnnotationsSelected = {({annotations}) =&gt; { annotations.forEach(annotation =&gt; { console.log('The id of selected annotation is', annotation.id); console.log('It is in page', annotation.pageNumber); console.log('Its type is', annotation.type); }); }} /&gt; onAnnotationChanged This function is called if a change has been made to an annotation(s) in the current document. Type: function Optional. Source: DocumentView.js line 616 Parameters: Name Type Description action string the action that occurred (add, delete, modify) annotations Array&lt;object&gt; array of annotation data in the format {id: string, pageNumber: number, type: string}, representing the annotations that have been changed. type is one of the Config.Tools constants Example &lt;DocumentView onAnnotationChanged = {({action, annotations}) =&gt; { console.log('Annotation edit action is', action); annotations.forEach(annotation =&gt; { console.log('The id of changed annotation is', annotation.id); console.log('It is in page', annotation.pageNumber); console.log('Its type is', annotation.type); }); }} /&gt; onFormFieldValueChanged This function is called if a change has been made to form field values. Type: function Optional. Source: DocumentView.js line 638 Parameters: Name Type Description fields Array&lt;object&gt; array of field data in the format {fieldName: string, fieldType: string, fieldValue: any}, representing the fields that have been changed Example &lt;DocumentView onFormFieldValueChanged = {({fields}) =&gt; { fields.forEach(field =&gt; { console.log('The name of the changed field is', field.fieldName); console.log('The type of the changed field is', field.fieldType); console.log('The value of the changed field is', field.fieldValue); }); }} /&gt; Bookmark onBookmarkChanged This function is called if a change has been made to user bookmarks. Type: function Optional. Source: DocumentView.js line 1147 Parameters: Name Type Description bookmarkJson string the list of current bookmarks in JSON format Example &lt;DocumentView onBookmarkChanged = {({bookmarkJson}) =&gt; { console.log('Bookmarks have been changed. Current bookmark collection is', bookmarkJson); }} /&gt; Custom Behavior onBehaviorActivated This function is called if the activated behavior is passed in to overrideBehavior Type: function Optional. Source: DocumentView.js line 483 Parameters: Name Type Description action Config.Actions the action which has been activated. data object A JSON object that varies depending on the action. If action is Config.Actions.linkPress, data type is {url: string}. If action is Config.Actions.stickyNoteShowPopUp, data type is {id: string, pageNumber: number, type: string, screenRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}, pageRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}} type is one of the Config.Tools constants, screenRect was formerly called rect. Example &lt;DocumentView onBehaviorActivated = {({action, data}) =&gt; { console.log('Activated action is', action); if (action === Config.Actions.linkPress) { console.log('The external link pressed is', data.url); } else if (action === Config.Actions.stickyNoteShowPopUp) { console.log('Sticky note has been activated, but it would not show a pop up window.'); } }} /&gt; Import/Export Annotations onExportAnnotationCommand This function is called if a change has been made to annotations in the current document. Unlike onAnnotationChanged, this function has an XFDF command string as its parameter. If you are modifying or deleting multiple annotations, then on Android the function is only called once, and on iOS it is called for each annotation. Known Issues On iOS, there is currently a bug that prevents the last XFDF from being retrieved when modifying annotations while collaboration mode is enabled. Type: function Optional. Source: DocumentView.js line 886 Parameters: Name Type Description action string the action that occurred (add, delete, modify) xfdfCommand string an xfdf string containing info about the edit annotations array an array of annotation data. When collaboration is enabled data comes in the format {id: string}, otherwise the format is {id: string, pageNumber: number, type: string}. In both cases, the data represents the annotations that have been changed. type is one of the Config.Tools constants. Example &lt;DocumentView onExportAnnotationCommand = {({action, xfdfCommand, annotations}) =&gt; { console.log('Annotation edit action is', action); console.log('The exported xfdfCommand is', xfdfCommand); annotations.forEach((annotation) =&gt; { console.log('Annotation id is', annotation.id); if (!this.state.collabEnabled) { console.log('Annotation pageNumber is', annotation.pageNumber); console.log('Annotation type is', annotation.type); } }); }} collabEnabled={this.state.collabEnabled} currentUser={'Pdftron'} /&gt; Layout onLayoutChanged This function is called when the layout of the viewer has been changed. Type: function Optional. Source: DocumentView.js line 707 Example &lt;DocumentView onLayoutChanged = {() =&gt; { console.log('Layout has been updated.'); }} /&gt; Long Press Menu onLongPressMenuPress This function is called if the pressed long press menu item is passed in to overrideLongPressMenuBehavior. Type: function Optional. Source: DocumentView.js line 345 Parameters: Name Type Description longPressMenu Config.LongPressMenu the menu item that has been pressed. longPressText string the selected text if pressed on text, empty otherwise Example &lt;DocumentView onLongPressMenuPress = {({longPressMenu, longPressText}) =&gt; { console.log('Long press menu item', longPressMenu, 'has been pressed'); if (longPressText !== '') { console.log('The selected text is', longPressText); } }} /&gt; Multi-tab onTabChanged The function is activated when a tab is changed. This API is meant for tab-specific changes. If you would like to know when the document finishes loading instead, see the onDocumentLoaded event. Type: function Optional. Source: DocumentView.js line 1654 Parameters: Name Type Description currentTab string The file path of current tab's document Example &lt;DocumentView multiTabEnabled={true} onTabChanged={({currentTab}) =&gt; { console.log(\"The current tab is \", currentTab); }} /&gt; Open a Document onDocumentLoaded This function is called when the document finishes loading. Type: function Optional. Source: DocumentView.js line 173 Parameters: Name Type path string Example &lt;DocumentView onDocumentLoaded = {(path) =&gt; { console.log('The document has finished loading:', path); }} /&gt; onDocumentError This function is called when document opening encounters an error. Type: function Optional. Source: DocumentView.js line 189 Parameters: Name Type error string Example &lt;DocumentView onDocumentError = {(error) =&gt; { console.log('Error occured during document opening:', error); }} /&gt; Page onPageChanged This function is called when the page number has been changed. Type: function Optional. Source: DocumentView.js line 206 Parameters: Name Type Description previousPageNumber int the previous page number pageNumber int the current page number Example &lt;DocumentView onPageChanged = {({previousPageNumber, pageNumber}) =&gt; { console.log('Page number changes from', previousPageNumber, 'to', pageNumber); }} /&gt; onPageMoved This function is called when a page has been moved in the document. Type: function Optional. Source: DocumentView.js line 1633 Parameters: Name Type Description previousPageNumber int the previous page number pageNumber int the current page number Example &lt;DocumentView onPageMoved = {({previousPageNumber, pageNumber}) =&gt; { console.log('Page moved from', previousPageNumber, 'to', pageNumber); }} /&gt; Scroll onScrollChanged This function is called when the scroll position has been changed. Type: function Optional. Source: DocumentView.js line 224 Parameters: Name Type Description horizontal number the horizontal position of the scroll vertical number the vertical position of the scroll Example &lt;DocumentView onScrollChanged = {({horizontal, vertical}) =&gt; { console.log('Current scroll position is', horizontal, 'horizontally, and', vertical, 'vertically.'); }} /&gt; Text Selection onTextSearchStart This function is called immediately before a text search begins, either through user actions, or function calls such as findText. Type: function Optional. Source: DocumentView.js line 1219 Example &lt;DocumentView onTextSearchStart = {() =&gt; { console.log('Text search has started'); }} /&gt; onTextSearchResult This function is called after a text search is finished or canceled. Type: function Optional. Source: DocumentView.js line 1257 Parameters: Name Type Description found boolean whether a result is found. If false, it could be caused by not finding a matching result in the document, invalid text input, or action cancellation (user actions or cancelFindText) textSelection object the text selection, in the format {html: string, unicode: string, pageNumber: number, quads: [[{x: number, y: number}, {x: number, y: number}, {x: number, y: number}, {x: number, y: number}], ...]}. If no such selection could be found, this would be null Quads indicate the quad boundary boxes for the selection, which could have a size larger than 1 if selection spans across different lines. Each quad have 4 points with x, y coordinates specified in number, representing a boundary box. The 4 points are in counter-clockwise order, though the first point is not guaranteed to be on lower-left relatively to the box. Example &lt;DocumentView onTextSearchResult = {({found, textSelection}) =&gt; { if (found) { console.log('Found selection on page', textSelection.pageNumber); for (let i = 0; i &lt; textSelection.quads.length; i ++) { const quad = textSelection.quads[i]; console.log('selection boundary quad', i); for (const quadPoint of quad) { console.log('A quad point has coordinates', quadPoint.x, quadPoint.y); } } } }} /&gt; UI Customization onLeadingNavButtonPressed This function is called when the leading navigation button is pressed. Type: function Optional. Source: DocumentView.js line 157 Example &lt;DocumentView onLeadingNavButtonPressed = {() =&gt; { console.log('The leading nav has been pressed'); }} /&gt; onToolChanged This function is called when the current tool changes to a new tool Type: function Optional. Source: DocumentView.js line 1179 Parameters: Name Type Description previousTool Config.Tools | string the previous tool (one of the Config.Tools constants or \"unknown tool\"), representing the tool before change tool Config.Tools | string the current tool (one of the Config.Tools constants or \"unknown tool\"), representing the current tool Example &lt;DocumentView onToolChanged = {({previousTool, tool}) =&gt; { console.log('Tool has been changed from', previousTool, 'to', tool); }} /&gt; Undo/Redo onUndoRedoStateChanged This function is called when the state of the current document's undo/redo stack has been changed. Type: function Optional. Source: DocumentView.js line 1430 Example &lt;DocumentView onUndoRedoStateChanged = {() =&gt; { console.log(\"Undo/redo stack state changed\"); }} /&gt; Zoom onZoomChanged This function is called when the zoom scale has been changed. Type: function Optional. Source: DocumentView.js line 240 Parameters: Name Type Description zoom double the current zoom ratio of the document Example &lt;DocumentView onZoomChanged = {(zoom) =&gt; { console.log('Current zoom ratio is', zoom); }} /&gt; onZoomFinished This function is called when a zooming has been finished. For example, if zoom via gesture, this is called on gesture release. Type: function Optional. Source: DocumentView.js line 257 Parameters: Name Type Description zoom double the current zoom ratio of the document Example &lt;DocumentView onZoomFinished = {(zoom) =&gt; { console.log('Current zoom ratio is', zoom); }} /&gt;  Search results Close Documentation generated by JSDoc 3.6.7 on 2021-10-04T11:23:33-07:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" PDFTron React Native Classes ConfigDocumentViewPDFViewCtrlRNPdftron Events onAnnotationMenuPressonAnnotationsSelectedonAnnotationChangedonFormFieldValueChangedonBookmarkChangedonBehaviorActivatedonExportAnnotationCommandonLayoutChangedonLongPressMenuPressonTabChangedonDocumentLoadedonDocumentErroronPageChangedonPageMovedonScrollChangedonTextSearchStartonTextSearchResultonLeadingNavButtonPressedonToolChangedonUndoRedoStateChangedonZoomChangedonZoomFinished PDFTron React Native API PDFTron's React Native PDF Library allows applications to use JavaScript to build cross-platform mobile apps. The application UI is rendered using native views to provide users the fluid look and feel of traditional native applications. TypeScript Starting with version 3.0.0, PDFTron React Native provides support for TypeScript! For TypeScript users, type information is automatically provided while coding. Exact type aliases and constants used in our custom typings can also be found in our TypeScript source files. The typings used in these API docs will be described using normal JavaScript types. Frequently used Config - Defines configuration constants for the viewer. DocumentView - An all-in-one React component for displaying and editing documents of different types. PDFViewCtrl - A React component for displaying documents when a higher level of customization is required. RNPdftron - Contains static methods for global library initialization, configuration, and utility methods. Links For instantiation, information, and source code, see our GitHub. For guides and support, visit us at the PDFTron website.  Search results Close Documentation generated by JSDoc 3.6.7 on 2021-10-04T11:23:33-07:00 using the DocStrap template. "},"DocumentView.html":{"id":"DocumentView.html","title":"Class: DocumentView","body":" PDFTron React Native Classes ConfigDocumentViewPDFViewCtrlRNPdftron Events onAnnotationMenuPressonAnnotationsSelectedonAnnotationChangedonFormFieldValueChangedonBookmarkChangedonBehaviorActivatedonExportAnnotationCommandonLayoutChangedonLongPressMenuPressonTabChangedonDocumentLoadedonDocumentErroronPageChangedonPageMovedonScrollChangedonTextSearchStartonTextSearchResultonLeadingNavButtonPressedonToolChangedonUndoRedoStateChangedonZoomChangedonZoomFinished DocumentView An all-in-one React component for displaying and editing documents of different types such as PDF, docx, pptx, xlsx and various image formats. Due to the length of the source file, we have included links to the exact lines of the source code where these APIs have been implemented. Source: DocumentView.js line 1716 Members Annotation Menu annotationMenuItems Defines the menu items that can show when an annotation is selected. Type: Array&lt;Config.AnnotationMenu&gt; Optional. Default Value: Contains all the items. Source: DocumentView.js line 372 Example &lt;DocumentView annotationMenuItems={[Config.AnnotationMenu.search, Config.AnnotationMenu.share]} /&gt; overrideAnnotationMenuBehavior Defines the menu items that will skip default behavior when pressed. They will still be displayed in the annotation menu, and the function onAnnotationMenuPress will be called where custom behavior can be implemented. Type: Array&lt;Config.AnnotationMenu&gt; Optional. Default Value: Defaults to none. Source: DocumentView.js line 388 Example &lt;DocumentView overrideAnnotationMenuBehavior={[Config.AnnotationMenu.copy]} /&gt; hideAnnotationMenu Defines annotation types that will not show in the annotation (long-press) menu. Type: Array&lt;Config.Tools&gt; Optional. Default Value: Defaults to none. Source: DocumentView.js line 434 Example &lt;DocumentView hideAnnotationMenu={[Config.Tools.annotationCreateArrow, Config.Tools.annotationEraserTool]} /&gt; Annotations continuousAnnotationEditing If true, the active annotation creation tool will remain in the current annotation creation tool. Otherwise, it will revert to the \"pan tool\" after an annotation is created. Type: boolean Optional. Default Value: true Source: DocumentView.js line 736 Example &lt;DocumentView continuousAnnotationEditing={true} /&gt; selectAnnotationAfterCreation Defines whether an annotation is selected after it is created. On iOS, this functions for shape and text markup annotations only. Type: boolean Optional. Default Value: true Source: DocumentView.js line 750 Example &lt;DocumentView selectAnnotationAfterCreation={true} /&gt; annotationAuthor Defines the author name for all annotations created on the current document. Exported xfdfCommand will include this piece of information. Type: string Optional. Source: DocumentView.js line 763 Example &lt;DocumentView annotationAuthor={'PDFTron'} /&gt; annotationPermissionCheckEnabled Defines whether an annotation's permission flags will be respected when it is selected. For example, a locked annotation can not be resized or moved. Type: boolean Optional. Default Value: false Source: DocumentView.js line 1014 Example &lt;DocumentView annotationPermissionCheckEnabled={true} /&gt; annotationsListEditingEnabled Android only If document editing is enabled, then this value determines if the annotation list is editable. Type: boolean Optional. Default Value: true Source: DocumentView.js line 1345 Example &lt;DocumentView annotationsListEditingEnabled={true} /&gt; inkMultiStrokeEnabled If true, ink tool will use multi-stroke mode. Otherwise, each stroke is a new ink annotation. Type: boolean Optional. Default Value: true Source: DocumentView.js line 1477 Example &lt;DocumentView inkMultiStrokeEnabled={true} /&gt; disableEditingByAnnotationType Defines annotation types that cannot be edited after creation. Type: Array&lt;Config.Tools&gt; Optional. Default Value: Defaults to none. Source: DocumentView.js line 1540 Example &lt;DocumentView disableEditingByAnnotationType={[Config.Tools.annotationCreateTextSquiggly, Config.Tools.annotationCreateEllipse]} /&gt; excludedAnnotationListTypes Defines types to be excluded from the annotation list. Type: Array&lt;Config.Tools&gt; Optional. Default Value: Defaults to none. Source: DocumentView.js line 1599 Example &lt;DocumentView excludedAnnotationListTypes={[Config.Tools.annotationCreateEllipse, Config.Tools.annotationCreateRectangle, Config.Tools.annotationCreateRedaction]} /&gt; Bookmark userBookmarksListEditingEnabled Defines whether the bookmark list can be edited. If the viewer is readonly then bookmarks on Android are still editable but are saved to the device rather than the PDF. Type: boolean Optional. Default Value: true Source: DocumentView.js line 1386 Example &lt;DocumentView userBookmarksListEditingEnabled={true} /&gt; Collaboration collabEnabled Defines whether to enable realtime collaboration. If true then currentUser must be set as well for collaboration mode to work. Feature set may vary between local and collaboration mode. Type: boolean Optional. Default Value: false Source: DocumentView.js line 811 Example &lt;DocumentView collabEnabled={true} currentUser={'Pdftron'} /&gt; currentUser Required if collabEnabled is set to true. Defines the current user. Created annotations will have their title (author) set to this string. Type: string Source: DocumentView.js line 826 Example &lt;DocumentView collabEnabled={true} currentUser={'Pdftron'} /&gt; currentUserName Defines the current user name. Will set the user name only if collabEnabled is true and currentUser is defined. This should be used only if you want the user's display name to be different than the annotation's title/author (in the case that currentUser is an ID rather than a human-friendly name.) Type: string Optional. Source: DocumentView.js line 845 Example &lt;DocumentView collabEnabled={true} currentUser={'Pdftron'} currentUserName={'Hello_World'} /&gt; replyReviewStateEnabled Android only. Defines whether to show an annotation's reply review state. Type: boolean Optional. Default Value: true Source: DocumentView.js line 1616 Example &lt;DocumentView collabEnabled={true} currentUser={'Pdftron'} replyReviewStateEnabled={true} /&gt; Custom Behavior overrideBehavior Defines actions that will skip default behavior, such as external link click. The function onBehaviorActivated will be called where custom behavior can be implemented, whenever the defined actions occur. Type: Array&lt;Config.Actions&gt; Optional. Default Value: Defaults to none. Source: DocumentView.js line 449 Example &lt;DocumentView overrideBehavior={[Config.Actions.linkPress]} /&gt; Layout fitMode Defines the fit mode (default zoom level) of the viewer. Type: Config.FitMode Optional. Default Value: Config.FitMode.FitWidth Source: DocumentView.js line 679 Example &lt;DocumentView fitMode={Config.FitMode.FitPage} /&gt; layoutMode Defines the layout mode of the viewer. Type: Config.LayoutMode Optional. Default Value: Config.LayoutMode.Continuous Source: DocumentView.js line 692 Example &lt;DocumentView layoutMode={Config.LayoutMode.FacingContinuous} /&gt; Long Press Menu longPressMenuItems Defines menu items that can show when long press on text or blank space. Type: Array&lt;Config.LongPressMenu&gt; Optional. Default Value: Contains all the items. Source: DocumentView.js line 308 Example &lt;DocumentView longPressMenuItems={[Config.LongPressMenu.copy, Config.LongPressMenu.read]} /&gt; overrideLongPressMenuBehavior Defines the menu items on long press that will skip default behavior when pressed. They will still be displayed in the long press menu, and the function onLongPressMenuPress will be called where custom behavior can be implemented. Type: Array&lt;Config.LongPressMenu&gt; Optional. Default Value: Defaults to none. Source: DocumentView.js line 324 Example &lt;DocumentView overrideLongPressMenuBehavior={[Config.LongPressMenu.search]} /&gt; longPressMenuEnabled Defines whether to show the popup menu of options when the user long presses on text or blank space on the document. Type: boolean Optional. Default Value: true Source: DocumentView.js line 359 Example &lt;DocumentView longPressMenuEnabled={true} /&gt; Multi-tab multiTabEnabled Defines whether viewer will use tabs in order to have more than one document open simultaneously (like a web browser). Changing the document prop value will cause a new tab to be opened with the associated file. Type: boolean Optional. Default Value: false Source: DocumentView.js line 956 Example &lt;DocumentView multiTabEnabled={true} /&gt; tabTitle Set the tab title if multiTabEnabled is true. Type: string Optional. Default Value: the file name Source: DocumentView.js line 970 Example &lt;DocumentView multiTabEnabled={true} tabTitle={'tab1'} /&gt; maxTabCount Sets the limit on the maximum number of tabs that the viewer could have at a time. Open more documents after reaching this limit will overwrite the old tabs. Type: number Optional. Default Value: unlimited Source: DocumentView.js line 985 Example &lt;DocumentView multiTabEnabled={true} maxTabCount={5} /&gt; Navigation pageStackEnabled Android only. Defines whether the page stack navigation buttons will appear in the viewer. Type: boolean Optional. Default Value: true Source: DocumentView.js line 1289 Example &lt;DocumentView pageStackEnabled={false} /&gt; showQuickNavigationButton Defines whether the quick navigation buttons will appear in the viewer. Type: boolean Optional. Default Value: true Source: DocumentView.js line 1302 Example &lt;DocumentView showQuickNavigationButton={false} /&gt; showNavigationListAsSidePanelOnLargeDevices Defines whether the navigation list will be displayed as a side panel on large devices such as iPads and tablets. Type: boolean Optional. Default Value: true on Android and false on iOS Source: DocumentView.js line 1359 Example &lt;DocumentView showNavigationListAsSidePanelOnLargeDevices={true} /&gt; Open a Document document The path or url to the document. Required. Type: string Source: DocumentView.js line 31 Example &lt;DocumentView document={'https://pdftron.s3.amazonaws.com/downloads/pl/PDFTRON_about.pdf'} /&gt; password The password of the document, if any. Type: string Optional. Source: DocumentView.js line 43 Example &lt;DocumentView password={'password'} /&gt; customHeaders Defines custom headers to use with HTTP/HTTPS requests. Type: object Optional. Source: DocumentView.js line 82 Example &lt;DocumentView customHeaders={{headerKey: 'headerValue'}} /&gt; readOnly Defines whether the viewer is read-only. If true, the UI will not allow the user to change the document. Type: boolean Optional. Default Value: false Source: DocumentView.js line 652 Example &lt;DocumentView readOnly={true} /&gt; isBase64String If true, document prop will be treated as a base64 string. If it is not the base64 string of a pdf file, base64FileExtension is required. When viewing a document initialized with a base64 string (i.e. a memory buffer), a temporary file is created on Android and iOS. Type: boolean Optional. Default Value: false Source: DocumentView.js line 795 Example &lt;DocumentView isBase64String={true} document={'...'} // base 64 string /&gt; defaultEraserType Sets the default eraser tool type. Value only applied after a clean install. Eraser Type Description annotationEraser Erases everything as an object; if you touch ink, the entire object is erased. hybrideEraser | Erases ink by pixel, but erases other annotation types as objects. inkEraser | Erases ink by pixel only. Android only. Type: Config.EraserType Optional. Source: DocumentView.js line 1496 Example &lt;DocumentView defaultEraserType={Config.EraserType.hybrideEraser} /&gt; exportPath Android only. Sets the folder path for all save options, this defaults to the app cache path. Example: Type: string Optional. Source: DocumentView.js line 1511 Example &lt;DocumentView exportPath=\"/data/data/com.example/cache/test\" /&gt; openUrlPath Android only. Sets the cache folder used to cache PDF files opened using a http/https link, this defaults to the app cache path. Type: string Optional. Source: DocumentView.js line 1526 Example &lt;DocumentView openUrlPath=\"/data/data/com.example/cache/test\" /&gt; saveStateEnabled Sets whether to remember the last visited page and zoom for a document if it gets opened again. Type: boolean Optional. Default Value: true Source: DocumentView.js line 1569 Example &lt;DocumentView saveStateEnabled={false} /&gt; openSavedCopyInNewTab Android only. Sets whether the new saved file should open after saving. Type: boolean Optional. Default Value: true Source: DocumentView.js line 1584 Example &lt;DocumentView openSavedCopyInNewTab={false} /&gt; Other autoSaveEnabled Defines whether document is automatically saved by the viewer. Type: boolean Optional. Default Value: true Source: DocumentView.js line 898 Example &lt;DocumentView autoSaveEnabled={true} /&gt; followSystemDarkMode Android and iOS 13+ only Defines whether the UI will appear in a dark color when the system is dark mode. If false, it will use viewer setting instead. Type: boolean Optional. Default Value: true Source: DocumentView.js line 927 Example &lt;DocumentView followSystemDarkMode={false} /&gt; useStylusAsPen Defines whether a stylus should act as a pen when in pan mode. If false, it will act as a finger. Type: boolean Optional. Default Value: true Source: DocumentView.js line 940 Example &lt;DocumentView useStylusAsPen={true} /&gt; autoResizeFreeTextEnabled Defines whether to automatically resize the bounding box of free text annotations when editing. Type: boolean Optional. Default Value: false Source: DocumentView.js line 1330 Example &lt;DocumentView autoResizeFreeTextEnabled={true} /&gt; restrictDownloadUsage Defines whether to restrict data usage when viewing online PDFs. Type: boolean Optional. Default Value: false Source: DocumentView.js line 1371 Example &lt;DocumentView restrictDownloadUsage={true} /&gt; Page initialPageNumber Defines the initial page number that viewer displays when the document is opened. Note that page numbers are 1-indexed. Type: number Optional. Source: DocumentView.js line 56 Example &lt;DocumentView initialPageNumber={5} /&gt; pageNumber Defines the currently displayed page number. Different from initialPageNumber, changing this prop value at runtime will change the page accordingly. Type: number Optional. Source: DocumentView.js line 70 Example &lt;DocumentView pageNumber={5} /&gt; pageIndicatorEnabled Defines whether to show the page indicator for the viewer. Type: boolean Optional. Default Value: true Source: DocumentView.js line 546 Example &lt;DocumentView pageIndicatorEnabled={true} /&gt; keyboardShortcutsEnabled iOS only Defines whether the keyboard shortcuts of the viewer are enabled. Type: boolean Optional. Default Value: true Source: DocumentView.js line 561 Example &lt;DocumentView keyboardShortcutsEnabled={false} /&gt; pageChangeOnTap Defines whether the viewer should change pages when the user taps the edge of a page, when the viewer is in a horizontal viewing mode. Type: boolean Optional. Default Value: true Source: DocumentView.js line 912 Example &lt;DocumentView pageChangeOnTap={true} /&gt; Reflow imageInReflowEnabled Whether to show images in reflow mode. Type: boolean Optional. Default Value: true Source: DocumentView.js line 1399 Example &lt;DocumentView imageInReflowEnabled={false} /&gt; reflowOrientation Android only. Sets the scrolling direction of the reflow control. Type: Config.ReflowOrientation Optional. Default Value: Config.ReflowOrientation.Horizontal Source: DocumentView.js line 1414 Example &lt;DocumentView reflowOrientation={Config.ReflowOrientation.Vertical} /&gt; Scroll horizontalScrollPos Defines the horizontal scroll position in the current document viewer. Type: number Optional. Source: DocumentView.js line 1191 Example &lt;DocumentView horizontalScrollPos={50} /&gt; verticalScrollPos Defines the vertical scroll position in the current document viewer. Type: number Optional. Source: DocumentView.js line 1203 Example &lt;DocumentView verticalScrollPos={50} /&gt; hideScrollbars iOS only. Determines whether scrollbars will be hidden on the viewer. Type: boolean Optional. Default Value: false Source: DocumentView.js line 1555 Example &lt;DocumentView hideScrollbars={true} /&gt; Signature showSavedSignatures Defines whether to show saved signatures for re-use when using the signing tool. Type: boolean Optional. Default Value: true Source: DocumentView.js line 776 Example &lt;DocumentView showSavedSignatures={true} /&gt; signSignatureFieldsWithStamps Defines whether signature fields will be signed with image stamps. This is useful if you are saving XFDF to remote source. Type: boolean Optional. Default Value: false Source: DocumentView.js line 1000 Example &lt;DocumentView signSignatureFieldsWithStamps={true} /&gt; photoPickerEnabled Android only. Defines whether to show the option to pick images in the signature dialog. Type: boolean Optional. Default Value: true. Source: DocumentView.js line 1317 Example &lt;DocumentView photoPickerEnabled={true} /&gt; Thumbnails thumbnailViewEditingEnabled Defines whether user can modify the document using the thumbnail view (eg add/remove/rotate pages). Type: boolean Optional. Default Value: true Source: DocumentView.js line 666 Example &lt;DocumentView thumbnailViewEditingEnabled={true} /&gt; hideThumbnailFilterModes Defines filter modes that should be hidden in the thumbnails browser. Type: Array&lt;Config.ThumbnailFilterMode&gt; Optional. Source: DocumentView.js line 1159 Example &lt;DocumentView hideThumbnailFilterModes={[Config.ThumbnailFilterMode.Annotated]} /&gt; Toolbar Customization topToolbarEnabled Type: boolean Deprecated: Use the hideTopAppNavBar prop instead. Optional. Default Value: true Source: DocumentView.js line 492 bottomToolbarEnabled Defines whether the bottom toolbar of the viewer is enabled. Type: boolean Optional. Default Value: true Source: DocumentView.js line 505 Example &lt;DocumentView bottomToolbarEnabled={false} /&gt; hideToolbarsOnTap Defines whether an unhandled tap in the viewer should toggle the visibility of the top and bottom toolbars. When false, the top and bottom toolbar visibility will not be toggled and the page content will fit between the bars, if any. Type: boolean Optional. Default Value: true Source: DocumentView.js line 520 Example &lt;DocumentView hideToolbarsOnTap={false} /&gt; padStatusBar Android only Defines whether the viewer will add padding to take account of the system status bar. Type: boolean Optional. Default Value: false Source: DocumentView.js line 722 Example &lt;DocumentView padStatusBar={true} /&gt; annotationToolbars Type can be array of Config.DefaultToolbars constants or custom toolbar objects. Defines custom toolbars. If passed in, the default toolbars will no longer appear. It is possible to mix and match with default toolbars. See example below. Type: Array&lt;Config.DefaultToolbars&gt; | object Optional. Default Value: Defaults to none. Source: DocumentView.js line 1038 Example const myToolbar = { [Config.CustomToolbarKey.Id]: 'myToolbar', [Config.CustomToolbarKey.Name]: 'myToolbar', [Config.CustomToolbarKey.Icon]: Config.ToolbarIcons.FillAndSign, [Config.CustomToolbarKey.Items]: [Config.Tools.annotationCreateArrow, Config.Tools.annotationCreateCallout, Config.Buttons.undo] }; ... &lt;DocumentView annotationToolbars={[Config.DefaultToolbars.Annotate, myToolbar]} /&gt; hideDefaultAnnotationToolbars Defines which default annotation toolbars should be hidden. Note that this prop should be used when annotationToolbars is not defined. Type: Array&lt;Config.DefaultToolbars&gt; Optional. Default Value: Defaults to none. Source: DocumentView.js line 1062 Example &lt;DocumentView hideDefaultAnnotationToolbars={[Config.DefaultToolbars.Annotate, Config.DefaultToolbars.Favorite]} /&gt; topAppNavBarRightBar iOS only Customizes the right bar section of the top app nav bar. If passed in, the default right bar section will not be used. Type: Array&lt;Config.Buttons&gt; Optional. Source: DocumentView.js line 1077 Example &lt;DocumentView topAppNavBarRightBar={[Config.Buttons.reflowButton, Config.Buttons.outlineListButton]} /&gt; bottomToolbar Only the outline list, thumbnail list, share, view mode, search, and reflow buttons are supported on Android. Defines a custom bottom toolbar. If passed in, the default bottom toolbar will not be used. Type: Array&lt;Config.Buttons&gt; Optional. Source: DocumentView.js line 1092 Example &lt;DocumentView bottomToolbar={[Config.Buttons.reflowButton, Config.Buttons.outlineListButton]} /&gt; hideAnnotationToolbarSwitcher Defines whether to show the toolbar switcher in the top toolbar. Type: boolean Optional. Default Value: false Source: DocumentView.js line 1105 Example &lt;DocumentView hideAnnotationToolbarSwitcher={false} /&gt; hideTopToolbars Defines whether to hide both the top app nav bar and the annotation toolbar. Type: boolean Optional. Default Value: false Source: DocumentView.js line 1118 Example &lt;DocumentView hideTopToolbars={false} /&gt; hideTopAppNavBar Defines whether to hide the top navigation app bar. Type: boolean Optional. Default Value: false Source: DocumentView.js line 1131 Example &lt;DocumentView hideTopAppNavBar={true} /&gt; initialToolbar Type can be one of the Config.DefaultToolbars constants or the id of a custom toolbar object. Defines which annotationToolbar should be selected when the document is opened. Type: Config.DefaultToolbars | string Optional. Default Value: Defaults to none. Source: DocumentView.js line 1463 Example &lt;DocumentView initialToolbar={Config.DefaultToolbars.Draw} /&gt; UI Customization leadingNavButtonIcon The file name of the icon to be used for the leading navigation button. The button will use the specified icon if it is valid, and the default icon otherwise. Note: to add the image file to your application, please follow the steps below: Android Add the image resource to the drawable directory in example/android/app/src/main/res. For details about supported file types and potential compression, check out here. 2. Now you can use the image in the viewer. For example, if you add `button_close.png` to drawable, you could use `'button_close'` in leadingNavButtonIcon. iOS After pods has been installed, open the .xcworkspace file for this application in Xcode (in this case, it's example.xcworkspace), and navigate through the list below. This would allow you to add resources, in this case, an image, to your project. \"Project navigator\" \"example\" (or the app name) \"Build Phases\" \"Copy Bundle Resources\" \"+\". 2. Now you can use the image in the viewer. For example, if you add `button_open.png` to the bundle, you could use `'button_open.png'` in leadingNavButtonIcon. Type: string Optional. Source: DocumentView.js line 129 Example let iosNav = 'ic_close_black_24px.png'; let androidNav = 'ic_arrow_back_white_24dp'; &lt;DocumentView leadingNavButtonIcon={Platform.OS === 'ios' ? iosNav : androidNav} /&gt; showLeadingNavButton Defines whether to show the leading navigation button. Type: boolean Optional. Default Value: true Source: DocumentView.js line 142 Example &lt;DocumentView showLeadingNavButton={true} /&gt; disabledElements Defines buttons to be disabled for the viewer. Type: Array&lt;Config.Buttons&gt; Optional. Default Value: Defaults to none. Source: DocumentView.js line 282 Example &lt;DocumentView disabledElements={[Config.Buttons.userBookmarkListButton]} /&gt; disabledTools Defines tools to be disabled for the viewer. Type: Array&lt;Config.Tools&gt; Optional. Default Value: Defaults to none. Source: DocumentView.js line 295 Example &lt;DocumentView disabledTools={[Config.Tools.annotationCreateLine, Config.Tools.annotationCreateRectangle]} /&gt; documentSliderEnabled Defines whether the document slider of the viewer is enabled. Type: boolean Optional. Default Value: true Source: DocumentView.js line 533 Example &lt;DocumentView documentSliderEnabled={false} /&gt; hideViewModeItems Defines view mode items to be hidden in the view mode dialog. Type: Array&lt;Config.ViewModePickerItem&gt; Optional. Default Value: Defaults to none. Source: DocumentView.js line 1274 Example &lt;DocumentView hideViewModeItems={[ Config.ViewModePickerItem.Crop, Config.ViewModePickerItem.Rotation, Config.ViewModePickerItem.ColorMode ]} /&gt; tabletLayoutEnabled Android only. Defines whether the tablet layout should be used on tablets. Otherwise uses the same layout as phones. Type: boolean Optional. Default Value: true Source: DocumentView.js line 1446 Example &lt;DocumentView tabletLayoutEnabled={true} /&gt; Zoom zoom Zoom factor used to display the page content. Type: number Optional. Source: DocumentView.js line 269 Example &lt;DocumentView zoom={1} /&gt; Methods Annotation Tools setToolMode Sets the current tool mode. Source: DocumentView.js line 1913 Parameters: Name Type Description toolMode Config.Tools the tool mode to set. Returns: Type Promise&lt;void&gt; Example this._viewer.setToolMode(Config.Tools.annotationCreateFreeHand).then(() =&gt; { // done switching tools }); commitTool Commits the current tool, only available for multi-stroke ink and poly-shape. Source: DocumentView.js line 1931 Returns: Name Type Description committed Promise&lt;(void|boolean)&gt; true if either ink or poly-shape tool is committed, false otherwise Example this._viewer.commitTool().then((committed) =&gt; { // committed: true if either ink or poly-shape tool is committed, false otherwise }); Annotations flattenAnnotations Flattens the forms and (optionally) annotations in the current document. Source: DocumentView.js line 2076 Parameters: Name Type Description formsOnly boolean Defines whether only forms are flattened. If false, all annotations will be flattened. Returns: Type Promise&lt;void&gt; Example // flatten forms and annotations in the current document. this._viewer.flattenAnnotations(false); deleteAnnotations Deletes the specified annotations in the current document. Source: DocumentView.js line 2103 Parameters: Name Type Description annotations Array&lt;object&gt; Defines which annotation to be deleted. Each element is in the format {id: string, pageNumber: int} Returns: Type Promise&lt;void&gt; Example // delete annotations in the current document. this._viewer.deleteAnnotations([ { id: 'annotId1', pageNumber: 1, }, { id: 'annotId2', pageNumber: 2, } ]); setFlagForFields Sets a field flag value on one or more form fields. Source: DocumentView.js line 2142 Parameters: Name Type Description fields Array&lt;string&gt; list of field names for which the flag should be set flag Config.FieldFlags flag to be set value boolean value to set for flag Returns: Type Promise&lt;void&gt; Example this._viewer.setFlagForFields(['First Name', 'Last Name'], Config.FieldFlags.ReadOnly, true); getField Get type and value information of a field using its name. Source: DocumentView.js line 2168 Parameters: Name Type Description fieldName string name of the field Returns: Name Type Description field Promise&lt;(void|object)&gt; an object with information keys: fieldName, fieldValue (undefined for fields with no values) and fieldType(one of button, checkbox, radio, text, choice, signature and unknown), or undefined if such field does not exist Example this._viewer.getField('someFieldName').then((field) =&gt; { if (field !== undefined) { console.log('field name:', field.fieldName); console.log('field value:', field.fieldValue); console.log('field type:', field.fieldType); } }); openAnnotationList Displays the annotation tab of the existing list container. If this tab has been disabled, the method does nothing. Source: DocumentView.js line 2184 Returns: Type Promise&lt;void&gt; Example this._viewer.openAnnotationList(); setValuesForFields Sets field values on one or more form fields. Note: the old function setValueForFields is deprecated. Please use this one instead. Source: DocumentView.js line 2218 Parameters: Name Type Description fieldsMap object map of field names and values which should be set Returns: Type Promise&lt;void&gt; Example this._viewer.setValuesForFields({ 'textField1': 'Test', 'textField2': 1234, 'checkboxField1': true, 'checkboxField2': false, 'radioButton1': 'Yes', 'radioButton2': 'No' }); setFlagsForAnnotations Sets flags for specified annotations in the current document. The flagValue controls whether a flag will be set to or removed from the annotation. Note: the old function setFlagForAnnotations is deprecated. Please use this one. Source: DocumentView.js line 2283 Parameters: Name Type Description annotationFlagList Array&lt;object&gt; A list of annotation flag operations. Each element is in the format {id: string, pageNumber: int, flag: One of Config.AnnotationFlags constants, flagValue: boolean} Returns: Type Promise&lt;void&gt; Example // Set flag for annotations in the current document. this._viewer.setFlagsForAnnotations([ { id: 'annotId1', pageNumber: 1, flag: Config.AnnotationFlags.noView, flagValue: true }, { id: 'annotId2', pageNumber: 5, flag: Config.AnnotationFlags.lockedContents, flagValue: false } ]); selectAnnotation Selects the specified annotation in the current document. Source: DocumentView.js line 2302 Parameters: Name Type Description id string the id of the target annotation pageNumber integer the page number where the targe annotation is located. It is 1-indexed. Returns: Type Promise&lt;void&gt; Example // select annotation in the current document. this._viewer.selectAnnotation('annotId1', 1); setPropertiesForAnnotation Sets properties for specified annotation in the current document, if it is valid. Note: the old function setPropertyForAnnotation is deprecated. Please use this one. Source: DocumentView.js line 2367 Parameters: Name Type Description annotationId string the unique id of the annotation pageNumber integer the page number where annotation is located. It is 1-indexed propertyMap object an object containing properties to be set. Available properties are listed below. Properties in propertyMap: Name Type Markup exclusive Example rect object no {x1: 1, y1: 2, x2: 3, y2: 4} contents string no \"contents\" subject string yes \"subject\" title string yes \"title\" contentRect object yes {x1: 1, y1: 2, x2: 3, y2: 4} customData object no {key: value} strokeColor object no {red: 255, green: 0, blue: 0} Returns: Type Promise&lt;void&gt; Example // Set properties for annotation in the current document. this._viewer.setPropertiesForAnnotation('Pdftron', 1, { rect: { x1: 1.1, // left y1: 3, // bottom x2: 100.9, // right y2: 99.8 // top }, contents: 'Hello World', subject: 'Sample', title: 'set-prop-for-annot', customData: { key1: 'value1', key2: 'value2', key3: 'value3' }, strokeColor: { \"red\": 255, \"green\": 0, \"blue\": 0 } }); getPropertiesForAnnotation Gets properties for specified annotation in the current document, if it is valid. Source: DocumentView.js line 2399 Parameters: Name Type Description annotationId string the unique id of the annotation pageNumber integer the page number where annotation is located. It is 1-indexed Returns: Name Type Description propertyMap Promise&lt;(void|object)&gt; the non-null properties of the annotation Name Type Markup exclusive Example rect object no {x1: 1, y1: 1, x2: 2, y2: 2, width: 1, height: 1} contents string no \"Contents\" subject string yes \"Subject\" title string yes \"Title\" contentRect object yes {x1: 1, y1: 1, x2: 2, y2: 2, width: 1, height: 1} strokeColor object no {red: 255, green: 0, blue: 0} Example // Get properties for annotation in the current document. this._viewer.getPropertiesForAnnotation('Pdftron', 1).then((properties) =&gt; { if (properties) { console.log('Properties for annotation: ', properties); } }) setDrawAnnotations Sets whether all annotations and forms should be rendered. This method affects the viewer and does not change the document. Unlike setVisibilityForAnnotation, this method is used to show and hide all annotations and forms in the viewer. Source: DocumentView.js line 2419 Parameters: Name Type Description drawAnnotations boolean whether all annotations and forms should be rendered Returns: Type Promise&lt;void&gt; Example this._viewer.setDrawAnnotations(false); setVisibilityForAnnotation Sets visibility for specified annotation in the current document, if it is valid. Note that if drawAnnotations is set to false in the viewer, this function would not render the annotation even if visibility is true. Source: DocumentView.js line 2441 Parameters: Name Type Description annotationId string the unique id of the annotation pageNumber integer the page number where annotation is located. It is 1-indexed visibility boolean whether the annotation should be visible Returns: Type Promise&lt;void&gt; Example this._viewer.setVisibilityForAnnotation('Pdftron', 1, true); setHighlightFields Enables or disables highlighting form fields. It is disabled by default. Source: DocumentView.js line 2456 Parameters: Name Type Description highlightFields boolean whether form fields should be highlighted Example this._viewer.setHighlightFields(true); getAnnotationAtPoint Gets an annotation at the (x, y) position in screen coordinates, if any. Source: DocumentView.js line 2490 Parameters: Name Type Description x integer the x-coordinate of the point y integer the y-coordinate of the point distanceThreshold double maximum distance from the point (x, y) to the annotation for it to be considered a hit (in dp) minimumLineWeight double For very thin lines, it is almost impossible to hit the actual line. This specifies a minimum line thickness (in screen coordinates) for the purpose of calculating whether a point is inside the annotation or not (in dp) Returns: Name Type Description annotation Promise&lt;(void|object)&gt; the annotation found in the format of {id: string, pageNumber: number, type: string, screenRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}, pageRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}}. type is one of the Config.Tools constants. screenRect was formerly called rect. Example this._viewer.getAnnotationAtPoint(167, 287, 100, 10).then((annotation) =&gt; { if (annotation) { console.log('Annotation found at point (167, 287) has id:', annotation.id); } }) getAnnotationListAt Gets the list of annotations at a given line in screen coordinates. Note that this is not an area selection. It should be used similar to getAnnotationAtPoint, except that this should be used when you want to get multiple annotations which are overlaying with each other. Source: DocumentView.js line 2523 Parameters: Name Type Description x1 integer x-coordinate of an endpoint on the line y1 integer y-coordinate of an endpoint on the line x2 integer x-coordinate of the other endpoint on the line, usually used as a threshold y2 integer y-coordinate of the other endpoint on the line, usually used as a threshold Returns: Name Type Description annotations Promise&lt;(void|Array&lt;object&gt;)&gt; list of annotations at the target line, each in the format of {id: string, pageNumber: number, type: string, screenRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}, pageRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}}. type is one of the Config.Tools constants. screenRect was formerly called rect. Example this._viewer.getAnnotationListAt(0, 0, 200, 200).then((annotations) =&gt; { for (const annotation of annotations) { console.log('Annotation found at line has id:', annotation.id); } }) getAnnotationsOnPage Gets the list of annotations on a given page. Source: DocumentView.js line 2550 Parameters: Name Type Description pageNumber integer the page number where annotations are located. It is 1-indexed Returns: Name Type Description annotations Promise&lt;(void|Array&lt;object&gt;)&gt; list of annotations on the target page, each in the format of {id: string, pageNumber: number, type: string, screenRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}, pageRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}}. type is one of the Config.Tools constants. screenRect was formerly called rect. Example this._viewer.getAnnotationsOnPage(2).then((annotations) =&gt; { for (const annotation of annotations) { console.log('Annotation found on page 2 has id:', annotation.id); } }) getCustomDataForAnnotation Gets an annotation's customData property. Source: DocumentView.js line 2577 Parameters: Name Type Description annotationId string the unique id of the annotation pageNumber integer the page number where annotation is located. It is 1-indexed key string the unique key associated with the customData property Returns: Name Type Description value Promise&lt;(void|string)&gt; the customData property associated with the given key Example this._viewer.setPropertiesForAnnotation(\"annotation1\", 2, { customData: { data: \"Nice annotation\" } }).then(() =&gt; { this._viewer.getCustomDataForAnnotation(\"annotation1\", 2, \"data\").then((value) =&gt; { console.log(value === \"Nice annotation\"); }) }) Bookmark importBookmarkJson Imports user bookmarks into the document. The input needs to be a valid bookmark JSON format. Source: DocumentView.js line 1966 Parameters: Name Type Description bookmarkJson string needs to be in valid bookmark JSON format, for example {\"0\": \"Page 1\"}. The page numbers are 1-indexed Returns: Type Promise&lt;void&gt; Example this._viewer.importBookmarkJson(\"{\\\"0\\\": \\\"Page 1\\\", \\\"3\\\": \\\"Page 4\\\"}\"); openBookmarkList Displays the bookmark tab of the existing list container. If this tab has been disabled, the method does nothing. Source: DocumentView.js line 1982 Returns: Type Promise&lt;void&gt; Example this._viewer.openBookmarkList(); Canvas getCanvasSize Returns the canvas size of current document viewer. Source: DocumentView.js line 2903 Returns: Type Description Promise&lt;(void|object)&gt; Name Type Description width number current width of canvas height number current height of canvas Example this._viewer.getCanvasSize().then(({width, height}) =&gt; { console.log('Current canvas width is:', width); console.log('Current canvas height is:', height); }); Coordinate convertScreenPointsToPagePoints Converts points from screen coordinates to page coordinates in the viewer. Source: DocumentView.js line 2977 Parameters: Name Type Description points Array&lt;object&gt; list of points, each in the format {x: number, y: number}. You could optionally have a pageNumber: number in the object. Without specifying, the page system is referring to the current page Returns: Name Type Description convertedPoints Promise&lt;(void|Array&lt;object&gt;)&gt; list of converted points in page system, each in the format {x: number, y: number}. It would be empty if conversion is unsuccessful Example // convert (50, 50) and (100, 100) from screen system to page system, // on current page and page 1 respectively this._viewer.convertScreenPointsToPagePoints([{x: 50, y: 50}, {x: 100, y:100, pageNumber: 1}]) .then((convertedPoints) =&gt; { convertedPoints.forEach(point =&gt; { console.log(point); }) }); convertPagePointsToScreenPoints Converts points from page coordinates to screen coordinates in the viewer. Source: DocumentView.js line 3003 Parameters: Name Type Description points Array&lt;object&gt; list of points, each in the format {x: number, y: number}. You could optionally have a pageNumber: number in the object. Without specifying, the page system is referring to the current page Returns: Name Type Description convertedPoints Promise&lt;(void|Array&lt;object&gt;)&gt; list of converted points in screen system, each in the format {x: number, y: number}. It would be empty if conversion is unsuccessful Example // convert (50, 50) on current page and (100, 100) on page 1 from page system to screen system this._viewer.convertPagePointsToScreenPoints([{x: 50, y: 50}, {x: 100, y:100, pageNumber: 1}]) .then((convertedPoints) =&gt; { convertedPoints.forEach(point =&gt; { console.log(point); }) }); getPageNumberFromScreenPoint Returns the page number that contains the point on screen. Source: DocumentView.js line 3022 Parameters: Name Type Description x number the x-coordinate of the screen point y number the y-coordinate of the screen point Returns: Name Type Description pageNumber Promise&lt;(void|number)&gt; the page number of the screen point Example this._viewer.getPageNumberFromScreenPoint(10.0,50.5).then((pageNumber) =&gt; { console.log('The page number of the screen point is', pageNumber); }); Document getDocumentPath Returns the path of the current document. If isBase64String is true, this would be the path to the temporary pdf file converted from the base64 string in document. Source: DocumentView.js line 1895 Returns: Name Type Description path Promise&lt;(void|string)&gt; the document path. Example this._viewer.getDocumentPath().then((path) =&gt; { console.log('The path to current document is: ' + path); }); saveDocument Saves the current document. If isBase64String is true, this would be the base64 string encoded from the temporary pdf file, which is created from the base64 string in document. Source: DocumentView.js line 2124 Returns: Name Type Description filePath Promise&lt;(void|string)&gt; the location of the saved document, or the base64 string of the pdf in the case of base64 Example this._viewer.saveDocument().then((filePath) =&gt; { console.log('saveDocument:', filePath); }); Import/Export Annotations importAnnotationCommand Imports remote annotation command to local document. Source: DocumentView.js line 2006 Parameters: Name Type Argument Default Description xfdfCommand string the XFDF command string initialLoad boolean &lt;optional&gt; false whether this is for initial load. Returns: Type Promise&lt;void&gt; Example const xfdfCommand = '&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;' + '&lt;xfdf xmlns=\"http://ns.adobe.com/xfdf/\" xml:space=\"preserve\"&gt;' + '&lt;add&gt;&lt;circle style=\"solid\" width=\"5\" color=\"#E44234\" opacity=\"1\" ' + 'creationdate=\"D:20201218025606Z\" flags=\"print\" date=\"D:20201218025606Z\" ' + 'name=\"9d0f2d63-a0cc-4f06-b786-58178c4bd2b1\" page=\"0\" ' + 'rect=\"56.4793,584.496,208.849,739.369\" title=\"PDF\" /&gt;&lt;/add&gt;&lt;modify /&gt;&lt;delete /&gt;' + '&lt;pdf-info import-version=\"3\" version=\"2\" xmlns=\"http://www.pdftron.com/pdfinfo\" /&gt;&lt;/xfdf&gt;'; this._viewer.importAnnotationCommand(xfdfCommand); importAnnotations Imports XFDF annotation string to the current document. Source: DocumentView.js line 2032 Parameters: Name Type Description xfdf string annotation string in XFDF format for import Returns: Type Promise&lt;void&gt; Example const xfdf = '&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\\n' + '&lt;xfdf xmlns=\"http://ns.adobe.com/xfdf/\" xml:space=\"preserve\"&gt;\\n\\t&lt;annots&gt;\\n\\t\\t' + '&lt;circle style=\"solid\" width=\"5\" color=\"#E44234\" opacity=\"1\" ' + 'creationdate=\"D:20190729202215Z\" flags=\"print\" date=\"D:20190729202215Z\" page=\"0\" ' + 'rect=\"138.824,653.226,236.28,725.159\" title=\"\" /&gt;&lt;/annots&gt;\\n\\t&lt;pages&gt;\\n\\t\\t' + '&lt;defmtx matrix=\"1.333333,0.000000,0.000000,-1.333333,0.000000,1056.000000\" /&gt;\\n\\t&lt;/pages&gt;' + '\\n\\t&lt;pdf-info version=\"2\" xmlns=\"http://www.pdftron.com/pdfinfo\" /&gt;\\n&lt;/xfdf&gt;'; this._viewer.importAnnotations(xfdf); exportAnnotations Extracts XFDF from the current document. Source: DocumentView.js line 2058 Parameters: Name Type Description options object key: annotList, type: array. If specified, annotations with the matching id and pageNumber will be exported; otherwise, all annotations in the current document will be exported. Returns: Name Type Description xfdf Promise&lt;(void|string)&gt; annotation string in XFDF format Examples Without options: this._viewer.exportAnnotations().then((xfdf) =&gt; { console.log('XFDF for all annotations:', xfdf); }); With options: // annotList is an array of annotation data in the format {id: string, pageNumber: int} const annotations = [{id: 'annot1', pageNumber: 1}, {id: 'annot2', pageNumber: 3}]; this._viewer.exportAnnotations({annotList: annotations}).then((xfdf) =&gt; { console.log('XFDF for 2 specified annotations', xfdf); }); Multi-tab closeAllTabs Closes all tabs in a multi-tab environment. Source: DocumentView.js line 2748 Returns: Type Promise&lt;void&gt; Example // Do this only when DocumentView has multiTabEnabled = true this._viewer.closeAllTabs(); openTabSwitcher Opens the tab switcher in a multi-tab environment. Source: DocumentView.js line 2764 Returns: Type Promise&lt;void&gt; Example // Do this only when DocumentView has multiTabEnabled = true this._viewer.openTabSwitcher(); Navigation handleBackButton Handles the back button in search mode. Android only. Source: DocumentView.js line 2237 Returns: Name Type Description handled Promise&lt;(void|boolean)&gt; whether the back button is handled successfully Example this._viewer.handleBackButton().then((handled) =&gt; { if (!handled) { BackHandler.exitApp(); } }); Other exportAsImage Export a PDF page to image format defined in Config.ExportFormat. Unlike RNPdftron.exportAsImage, this is a viewer method and should only be called after the document has been loaded or else unexpected behaviour can occur. This method uses the PDF that is associated with the viewer, and does not take a local file path to the desired PDF. Source: DocumentView.js line 3462 Parameters: Name Type Description pageNumber int the page to be converted; if the value does not refer to a valid page number, the file path will be undefined dpi double the output image resolution exportFormat Config.ExportFormat image format to be exported to Returns: Name Type Description path Promise&lt;(void|string)&gt; the temp path of the created image, user is responsible for clean up the cache Example this._viewer.exportToImage(1, 92, Config.ExportFormat.BMP).then((path) =&gt; { console.log('export', path); }); showCrop Displays the page crop option. Android only. Source: DocumentView.js line 3542 Returns: Type Promise&lt;void&gt; Example this._viewer.showCrop(); showViewSettings Displays the view settings. Requires a source rect in screen co-ordinates. On iOS this rect will be the anchor point for the view. The rect is ignored on Android. Source: DocumentView.js line 3581 Parameters: Name Type Description rect map The rectangular area in screen co-ordinates with keys x1 (left), y1 (bottom), y1 (right), y2 (top). Coordinates are in double format. Returns: Type Promise&lt;void&gt; Example this._viewer.showViewSettings({'x1': 10.0, 'y1': 10.0, 'x2': 20.0, 'y2': 20.0}); showAddPagesView Displays the add pages view. Requires a source rect in screen co-ordinates. On iOS this rect will be the anchor point for the view. The rect is ignored on Android. Source: DocumentView.js line 3619 Parameters: Name Type Description rect map The rectangular area in screen co-ordinates with keys x1 (left), y1 (bottom), y1 (right), y2(top). Coordinates are in double format. Returns: Type Promise&lt;void&gt; Example this._viewer.showAddPagesView({'x1': 10.0, 'y1': 10.0, 'x2': 20.0, 'y2': 20.0}); shareCopy Displays the share copy view. Requires a source rect in screen co-ordinates. On iOS this rect will be the anchor point for the view. The rect is ignored on Android. Source: DocumentView.js line 3671 Parameters: Name Type Description rect map The rectangular area in screen co-ordinates with keys x1 (left), y1 (bottom), y1 (right), y2 (top). Coordinates are in double format. flattening boolean Whether the shared copy should be flattened before sharing. Returns: Type Promise&lt;void&gt; Example this._viewer.shareCopy({'x1': 10.0, 'y1': 10.0, 'x2': 20.0, 'y2': 20.0}, true); openOutlineList Displays the outline tab of the existing list container. If this tab has been disabled, the method does nothing. Source: DocumentView.js line 3706 Returns: Type Promise&lt;void&gt; Example this._viewer.openOutlineList(); openLayersList On Android it displays the layers dialog, while on iOS it displays the layers tab of the existing list container. If this tab has been disabled or there are no layers in the document, the method does nothing. Source: DocumentView.js line 3722 Returns: Type Promise&lt;void&gt; Example this._viewer.openLayersList(); openNavigationLists Displays the existing list container. Its current tab will be the one last opened. Source: DocumentView.js line 3736 Returns: Type Promise&lt;void&gt; Example this._viewer.openNavigationLists(); Page getPageCount Gets the current page count of the document. Source: DocumentView.js line 1948 Returns: Name Type Description pageCount Promise&lt;(void|number)&gt; the current page count of the document Example this._viewer.getPageCount().then((pageCount) =&gt; { console.log('pageCount', pageCount); }); getPageCropBox Gets the crop box for specified page as a JSON object. Source: DocumentView.js line 2598 Parameters: Name Type Description pageNumber integer the page number for the target crop box. It is 1-indexed Returns: Name Type Description cropBox Promise&lt;(void|object)&gt; an object with information about position (x1, y1, x2 and y2) and size (width and height) Example this._viewer.getPageCropBox(1).then((cropBox) =&gt; { console.log('bottom-left coordinate:', cropBox.x1, cropBox.y1); console.log('top-right coordinate:', cropBox.x2, cropBox.y2); console.log('width and height:', cropBox.width, cropBox.height); }); setCurrentPage Sets current page of the document. Source: DocumentView.js line 2618 Parameters: Name Type Description pageNumber integer the page number to be set as the current page; 1-indexed Returns: Name Type Description success Promise&lt;(void|boolean)&gt; whether the setting process was successful Example this._viewer.setCurrentPage(4).then((success) =&gt; { if (success) { console.log(\"Current page is set to 4.\"); } }); getVisiblePages Gets the visible pages in the current viewer as an array. Source: DocumentView.js line 2638 Returns: Name Type Description visiblePages Promise&lt;(void|Array&lt;number&gt;)&gt; a list of visible pages in the current viewer Example this._viewer.getVisiblePages().then((visiblePages) =&gt; { for (const page of visiblePages) { console.log('page', page, 'is visible.') } }); gotoPreviousPage Go to the previous page of the document. If on first page, it will stay on first page. Source: DocumentView.js line 2658 Returns: Name Type Description success Promise&lt;(void|boolean)&gt; whether the setting process was successful (no change due to staying in first page counts as being successful) Example this._viewer.gotoPreviousPage().then((success) =&gt; { if (success) { console.log(\"Go to previous page.\"); } }); gotoNextPage Go to the next page of the document. If on last page, it will stay on last page. Source: DocumentView.js line 2678 Returns: Name Type Description success Promise&lt;(void|boolean)&gt; whether the setting process was successful (no change due to staying in last page counts as being successful) Example this._viewer.gotoNextPage().then((success) =&gt; { if (success) { console.log(\"Go to next page.\"); } }); gotoFirstPage Go to the first page of the document. Source: DocumentView.js line 2697 Returns: Name Type Description success Promise&lt;(void|boolean)&gt; whether the setting process was successful Example this._viewer.gotoFirstPage().then((success) =&gt; { if (success) { console.log(\"Go to first page.\"); } }); gotoLastPage Go to the last page of the document. Source: DocumentView.js line 2716 Returns: Name Type Description success Promise&lt;(void|boolean)&gt; whether the setting process was successful Example this._viewer.gotoLastPage().then((success) =&gt; { if (success) { console.log(\"Go to last page.\"); } }); showGoToPageView Opens a go-to page dialog. If the user inputs a valid page number into the dialog, the viewer will go to that page. Source: DocumentView.js line 2732 Returns: Type Promise&lt;void&gt; Example this._viewer.showGoToPageView(); getPageRotation Gets the rotation value of all pages in the current document. Source: DocumentView.js line 2921 Returns: Name Type Description pageRotation Promise&lt;(void|number)&gt; the rotation degree of all pages, one of 0, 90, 180 or 270 (clockwise). Example this._viewer.getPageRotation().then((pageRotation) =&gt; { console.log('The current page rotation degree is' + pageRotation); }); rotateClockwise Rotates all pages in the current document in clockwise direction (by 90 degrees). Source: DocumentView.js line 2936 Returns: Type Promise&lt;void&gt; Example this._viewer.rotateClockwise(); rotateCounterClockwise Rotates all pages in the current document in counter-clockwise direction (by 90 degrees). Source: DocumentView.js line 2951 Returns: Type Promise&lt;void&gt; Example this._viewer.rotateCounterClockwise(); showRotateDialog Android only. Displays a rotate dialog. This dialog allows users to rotate pages of the opened document by 90, 180 and 270 degrees. It also displays a thumbnail of the current page at the selected rotation angle. Source: DocumentView.js line 3600 Returns: Type Promise&lt;void&gt; Example this._viewer.showRotateDialog(); Reflow isReflowMode Returns whether the viewer is currently in reflow mode. Source: DocumentView.js line 3636 Returns: Name Type Description inReflow Promise&lt;(void|boolean)&gt; whether the viewer is in reflow mode Example this._viewer.isReflowMode().then((inReflow) =&gt; { console.log(inReflow ? 'in reflow mode' : 'not in reflow mode'); }); toggleReflow Allows the user to programmatically enter and exit reflow mode. Source: DocumentView.js line 3651 Returns: Type Promise&lt;void&gt; Example this._viewer.toggleReflow(); Rendering Options setProgressiveRendering Sets whether the control will render progressively or will just draw once the entire view has been rendered. Source: DocumentView.js line 3043 Parameters: Name Type Description progressiveRendering boolean whether to render progressively initialDelay number delay before the progressive rendering timer is started, in milliseconds interval number delay between refreshes, in milliseconds Returns: Type Promise&lt;void&gt; Example // delay for 10s before start, and refresh every 1s this._viewer.setProgressiveRendering(true, 10000, 1000); setImageSmoothing Enables or disables image smoothing. The rasterizer allows a trade-off between rendering quality and rendering speed. This function can be used to indicate the preference between rendering speed and quality. Source: DocumentView.js line 3061 Parameters: Name Type Description imageSmoothing boolean whether to enable image smoothing Returns: Type Promise&lt;void&gt; Example this._viewer.setImageSmoothing(false); setOverprint Enables or disables support for overprint and overprint simulation. Overprint is a device dependent feature and the results will vary depending on the output color space and supported colorants (i.e. CMYK, CMYK+spot, RGB, etc). Source: DocumentView.js line 3079 Parameters: Name Type Description overprint Config.OverprintMode the mode of overprint Returns: Type Promise&lt;void&gt; Example this._viewer.setOverprint(Config.OverprintMode.Off); Scroll getScrollPos Returns the horizontal and vertical scroll position of current document viewer. Source: DocumentView.js line 2879 Returns: Type Description Promise&lt;(void|object)&gt; Name Type Description horizontal number current horizontal scroll position vertical number current vertical scroll position Example this._viewer.getScrollPos().then(({horizontal, vertical}) =&gt; { console.log('Current horizontal scroll position is:', horizontal); console.log('Current vertical scroll position is:', vertical); }); Signature getSavedSignatures Gets a list of absolute file paths to PDFs containing the saved signatures. Source: DocumentView.js line 3758 Returns: Name Type Description signatures Promise&lt;(void|Array&lt;string&gt;)&gt; an array of string containing the absolute file paths; if there are no saved signatures, the value is an empty array Example this._viewer.getSavedSignatures().then((signatures) =&gt; { if (signatures.length &gt; 0) { signatures.forEach((signature) =&gt; { console.log(signature); }); } }) getSavedSignatureFolder Retrieves the absolute file path to the folder containing the saved signatures. For Android, to get the folder containing the saved signature JPGs, use getSavedSignatureJpgFolder. Source: DocumentView.js line 3779 Returns: Name Type Description path Promise&lt;(void|string)&gt; the absolute file path to the folder Example this._viewer.getSavedSignatureFolder().then((path) =&gt; { if (path != null) { console.log(path); } }) getSavedSignatureJpgFolder Android only. Retrieves the absolute file path to the folder containing the saved signature JPGs. For Android, to get the folder containing the saved signature PDFs, use getSavedSignatureFolder. Source: DocumentView.js line 3802 Returns: Name Type Description path Promise&lt;(void|string)&gt; the absolute file path to the folder Example this._viewer.getSavedSignatureJpgFolder().then((path) =&gt; { if (path != null) { console.log(path); } }) Text Selection startSearchMode Search for a term and all matching results will be highlighted. Source: DocumentView.js line 3135 Parameters: Name Type Description searchString string the text to search for matchCase boolean indicates if it is case sensitive matchWholeWord boolean indicates if it matches an entire word only Returns: Type Promise&lt;void&gt; Example this._viewer.startSearchMode('PDFTron', false, false); exitSearchMode Finishes the current text search and remove all the highlights. Source: DocumentView.js line 3150 Returns: Type Promise&lt;void&gt; Example this._viewer.exitSearchMode(); findText Searches asynchronously, starting from the current page, for the given text. PDFViewCtrl automatically scrolls to the position so that the found text is visible. Source: DocumentView.js line 3171 Parameters: Name Type Description searchString string the text to search for matchCase boolean indicates if it is case sensitive matchWholeWord boolean indicates if it matches an entire word only searchUp boolean indicates if it searches upward regExp boolean indicates if searchString is a regular expression Returns: Type Promise&lt;void&gt; Example this._viewer.findText('PDFTron', false, false, true, false); cancelFindText Cancels the current text search thread, if exists. Source: DocumentView.js line 3186 Returns: Type Promise&lt;void&gt; Example this._viewer.cancelFindText(); openSearch Displays a search bar that allows the user to enter and search text within a document. Source: DocumentView.js line 3201 Returns: Type Promise&lt;void&gt; Example this._viewer.openSearch(); getSelection Returns the text selection on a given page, if any. Source: DocumentView.js line 3238 Parameters: Name Type Description pageNumber number the specified page number. It is 1-indexed Returns: Name Type Description selection Promise&lt;(void|object)&gt; the text selection, in the format {html: string, unicode: string, pageNumber: number, quads: [[{x: number, y: number}, {x: number, y: number}, {x: number, y: number}, {x: number, y: number}], ...]}. If no such selection could be found, this would be null Quads indicate the quad boundary boxes for the selection, which could have a size larger than 1 if selection spans across different lines. Each quad have 4 points with x, y coordinates specified in number, representing a boundary box. The 4 points are in counter-clockwise order, though the first point is not guaranteed to be on lower-left relatively to the box. Example this._viewer.getSelection(2).then((selection) =&gt; { if (selection) { console.log('Found selection on page', selection.pageNumber); for (let i = 0; i &lt; selection.quads.length; i ++) { const quad = selection.quads[i]; console.log('selection boundary quad', i); for (const quadPoint of quad) { console.log('A quad point has coordinates', quadPoint.x, quadPoint.y); } } } }); hasSelection Returns whether there is a text selection in the current document. Source: DocumentView.js line 3255 Returns: Name Type Description hasSelection Promise&lt;(void|boolean)&gt; whether a text selection exists Example this._viewer.hasSelection().then((hasSelection) =&gt; { console.log('There is a selection in the document.'); }); clearSelection Clears any text selection in the current document. Source: DocumentView.js line 3270 Returns: Type Promise&lt;void&gt; Example this._viewer.clearSelection(); getSelectionPageRange Returns the page range (beginning and end) that has text selection on it. Source: DocumentView.js line 3297 Returns: Type Description Promise&lt;(void|object)&gt; Name Type Description begin number the first page to have selection, -1 if there are no selections end number the last page to have selection, -1 if there are no selections Example this._viewer.getSelectionPageRange().then(({begin, end}) =&gt; { if (begin === -1) { console.log('There is no selection'); } else { console.log('The selection range is from', begin, 'to', end); } }); hasSelectionOnPage Returns whether there is a text selection on the specified page in the current document. Source: DocumentView.js line 3318 Parameters: Name Type Description pageNumber number the specified page number. It is 1-indexed Returns: Name Type Description hasSelection Promise&lt;(void|boolean)&gt; whether a text selection exists on the specified page Example this._viewer.hasSelectionOnPage(5).then((hasSelection) =&gt; { if (hasSelection) { console.log('There is a selection on page 5 in the document.'); } }); selectInRect Selects the text within the given rectangle region. Source: DocumentView.js line 3337 Parameters: Name Type Description rect object the rectangle region in the format of {x1: number, x2: number, y1: number, y2: number} Returns: Name Type Description selected Promise&lt;(void|boolean)&gt; whether there is text selected Example this._viewer.selectInRect({x1: 0, y1: 0, x2: 200.5, y2: 200.5}).then((selected) =&gt; { console.log(selected); }); isThereTextInRect Returns whether there is text in given rectangle region. Source: DocumentView.js line 3356 Parameters: Name Type Description rect object the rectangle region in the format of {x1: number, x2: number, y1: number, y2: number} Returns: Name Type Description hasText Promise&lt;(void|boolean)&gt; whether there is text in the region Example this._viewer.isThereTextInRect({x1: 0, y1: 0, x2: 200, y2: 200}).then((hasText) =&gt; { console.log(hasText); }); selectAll Selects all text on the page. Source: DocumentView.js line 3371 Returns: Type Promise&lt;void&gt; Example this._viewer.selectAll(); Thumbnails openThumbnailsView Display a page thumbnails view. This view allows users to navigate pages of a document. If thumbnailViewEditingEnabled is true, the user can also manipulate the document, including add, remove, re-arrange, rotate and duplicate pages. Source: DocumentView.js line 3691 Returns: Type Promise&lt;void&gt; Example this._viewer.openThumbnailsView(); Toolbar setCurrentToolbar Sets the current annotationToolbars for the viewer. Source: DocumentView.js line 3562 Parameters: Name Type Description toolbar Config.DefaultToolbars | string the toolbar to enable. Should be one of the Config.DefaultToolbars constants or the id of a custom toolbar object. Returns: Type Promise&lt;void&gt; Example this._viewer.setCurrentToolbar(Config.DefaultToolbars.Insert).then(() =&gt; { // done switching toolbar }); UI Customization setColorPostProcessMode Sets the color post processing transformation mode for the viewer. Source: DocumentView.js line 3095 Parameters: Name Type Description colorPostProcessMode Config.ColorPostProcessMode color post processing transformation mode Example this._viewer.setColorPostProcessMode(Config.ColorPostProcessMode.NightMode); setColorPostProcessColors Sets the white and black color for the color post processing transformation. Source: DocumentView.js line 3117 Parameters: Name Type Description whiteColor object the white color for the color post processing transformation, in the format {red: number, green: number, blue: number}. alpha could be optionally included (only Android would apply alpha), and all numbers should be in range [0, 255] blackColor object the black color for the color post processing transformation, in the same format as whiteColor Example const whiteColor = {\"red\": 0, \"green\": 0, \"blue\": 255}; const blackColor = {\"red\": 255, \"green\": 0, \"blue\": 0}; this._viewer.setColorPostProcessColors(whiteColor, blackColor); Undo/Redo undo Undo the last modification. Source: DocumentView.js line 3477 Returns: Type Promise&lt;void&gt; Example this._viewer.undo(); redo Redo the last modification. Source: DocumentView.js line 3492 Returns: Type Promise&lt;void&gt; Example this._viewer.redo(); canUndo Checks whether an undo operation can be performed from the current snapshot. Source: DocumentView.js line 3510 Returns: Name Type Description canUndo Promise&lt;(void|boolean)&gt; whether it is possible to undo from the current snapshot Example this._viewer.canUndo().then((canUndo) =&gt; { console.log(canUndo ? 'undo possible' : 'no action to undo'); }); canRedo Checks whether a redo operation can be perfromed from the current snapshot. Source: DocumentView.js line 3528 Returns: Name Type Description canRedo Promise&lt;(void|boolean)&gt; whether it is possible to redo from the current snapshot Example this._viewer.canRedo().then((canRedo) =&gt; { console.log(canRedo ? 'redo possible' : 'no action to redo'); }); Viewer Options setPageBorderVisibility Sets whether borders of each page are visible in the viewer, which is disabled by default. Source: DocumentView.js line 3387 Parameters: Name Type Description pageBorderVisibility boolean whether borders of each page are visible in the viewer Example this._viewer.setPageBorderVisibility(true); setPageTransparencyGrid Enables or disables transparency grid (check board pattern) to reflect page transparency, which is disabled by default. Source: DocumentView.js line 3403 Parameters: Name Type Description pageTransparencyGrid boolean whether to use the transparency grid Example this._viewer.setPageTransparencyGrid(true); setDefaultPageColor Sets the default page color of the viewer. Source: DocumentView.js line 3419 Parameters: Name Type Description defaultPageColor object the default page color, in the format {red: number, green: number, blue: number}, each number in range [0, 255] Example this._viewer.setDefaultPageColor({red: 0, green: 255, blue: 0}); // green color setBackgroundColor Sets the background color of the viewer. Source: DocumentView.js line 3435 Parameters: Name Type Description backgroundColor object the background color, in the format {red: number, green: number, blue: number}, each number in range [0, 255] Example this._viewer.setBackgroundColor({red: 0, green: 0, blue: 255}); // blue color Zoom getZoom Returns the current zoom scale of current document viewer. Source: DocumentView.js line 2781 Returns: Name Type Description zoom Promise&lt;(void|number)&gt; current zoom scale in the viewer Example this._viewer.getZoom().then((zoom) =&gt; { console.log('Zoom scale of the current document is:', zoom); }); setZoomLimits Sets the minimum and maximum zoom bounds of current viewer. Source: DocumentView.js line 2800 Parameters: Name Type Description zoomLimitMode Config.ZoomLimitMode defines whether bounds are relative to the standard zoom scale in the current viewer or absolute minimum double the lower bound of the zoom limit range maximum double the upper bound of the zoom limit range Returns: Type Promise&lt;void&gt; Example this._viewer.setZoomLimits(Config.ZoomLimitMode.Absolute, 1.0, 3.5); zoomWithCenter Sets the zoom scale in the current document viewer with a zoom center. Source: DocumentView.js line 2818 Parameters: Name Type Description zoom double the zoom ratio to be set x int the x-coordinate of the zoom center y int the y-coordinate of the zoom center Returns: Type Promise&lt;void&gt; Example this._viewer.zoomWithCenter(3.0, 100, 300); zoomToRect Zoom the viewer to a specific rectangular area in a page. Source: DocumentView.js line 2836 Parameters: Name Type Description pageNumber int the page number of the zooming area (1-indexed) rect object The rectangular area with keys x1 (left), y1 (bottom), y1 (right), y2 (top). Coordinates are in double Returns: Type Promise&lt;void&gt; Example this._viewer.zoomToRect(3, {'x1': 1.0, 'y1': 2.0, 'x2': 3.0, 'y2': 4.0}); smartZoom Zoom to a paragraph that contains the specified coordinate. If no paragraph contains the coordinate, the zooming would not happen. Source: DocumentView.js line 2855 Parameters: Name Type Description x int the x-coordinate of the target coordinate y int the y-coordinate of the target coordinate animated boolean whether the transition is animated Returns: Type Promise&lt;void&gt; Example this._viewer.smartZoom(100, 200, true); Events Annotation Menu onAnnotationMenuPress This function is called when an annotation menu item passed in to overrideAnnotationMenuBehavior is pressed. Type: function Optional. Source: DocumentView.js line 421 Parameters: Name Type Description annotationMenu Config.AnnotationMenu the menu item that has been pressed. annotations Array&lt;object&gt; An array of {id: string, pageNumber: number, type: string, screenRect: object, pageRect: object} objects. id is the annotation identifier and type is one of the Config.Tools constants. screenRect was formerly called rect. Both rects are represented with {x1: number, y1: number, x2: number, y2: number, width: number, height: number} objects. Example &lt;DocumentView onAnnotationMenuPress = {({annotationMenu, annotations}) =&gt; { console.log('Annotation menu item', annotationMenu, 'has been pressed'); annotations.forEach(annotation =&gt; { console.log('The id of selected annotation is', annotation.id); console.log('The page number of selected annotation is', annotation.pageNumber); console.log('The type of selected annotation is', annotation.type); console.log('The screenRect of selected annotation is', annotation.screenRect); console.log('The pageRect of selected annotation is', annotation.pageRect); }); }} /&gt; Annotations onAnnotationsSelected This function is called when an annotation(s) is selected. Type: function Optional. Source: DocumentView.js line 589 Parameters: Name Type Description annotations Array&lt;object&gt; array of annotation data in the format {id: string, pageNumber: number, type: string, screenRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}, pageRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}}, representing the selected annotations. type is one of the Config.Tools constants. screenRect was formerly called rect. Example &lt;DocumentView onAnnotationsSelected = {({annotations}) =&gt; { annotations.forEach(annotation =&gt; { console.log('The id of selected annotation is', annotation.id); console.log('It is in page', annotation.pageNumber); console.log('Its type is', annotation.type); }); }} /&gt; onAnnotationChanged This function is called if a change has been made to an annotation(s) in the current document. Type: function Optional. Source: DocumentView.js line 616 Parameters: Name Type Description action string the action that occurred (add, delete, modify) annotations Array&lt;object&gt; array of annotation data in the format {id: string, pageNumber: number, type: string}, representing the annotations that have been changed. type is one of the Config.Tools constants Example &lt;DocumentView onAnnotationChanged = {({action, annotations}) =&gt; { console.log('Annotation edit action is', action); annotations.forEach(annotation =&gt; { console.log('The id of changed annotation is', annotation.id); console.log('It is in page', annotation.pageNumber); console.log('Its type is', annotation.type); }); }} /&gt; onFormFieldValueChanged This function is called if a change has been made to form field values. Type: function Optional. Source: DocumentView.js line 638 Parameters: Name Type Description fields Array&lt;object&gt; array of field data in the format {fieldName: string, fieldType: string, fieldValue: any}, representing the fields that have been changed Example &lt;DocumentView onFormFieldValueChanged = {({fields}) =&gt; { fields.forEach(field =&gt; { console.log('The name of the changed field is', field.fieldName); console.log('The type of the changed field is', field.fieldType); console.log('The value of the changed field is', field.fieldValue); }); }} /&gt; Bookmark onBookmarkChanged This function is called if a change has been made to user bookmarks. Type: function Optional. Source: DocumentView.js line 1147 Parameters: Name Type Description bookmarkJson string the list of current bookmarks in JSON format Example &lt;DocumentView onBookmarkChanged = {({bookmarkJson}) =&gt; { console.log('Bookmarks have been changed. Current bookmark collection is', bookmarkJson); }} /&gt; Custom Behavior onBehaviorActivated This function is called if the activated behavior is passed in to overrideBehavior Type: function Optional. Source: DocumentView.js line 483 Parameters: Name Type Description action Config.Actions the action which has been activated. data object A JSON object that varies depending on the action. If action is Config.Actions.linkPress, data type is {url: string}. If action is Config.Actions.stickyNoteShowPopUp, data type is {id: string, pageNumber: number, type: string, screenRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}, pageRect: {x1: number, y1: number, x2: number, y2: number, width: number, height: number}} type is one of the Config.Tools constants, screenRect was formerly called rect. Example &lt;DocumentView onBehaviorActivated = {({action, data}) =&gt; { console.log('Activated action is', action); if (action === Config.Actions.linkPress) { console.log('The external link pressed is', data.url); } else if (action === Config.Actions.stickyNoteShowPopUp) { console.log('Sticky note has been activated, but it would not show a pop up window.'); } }} /&gt; Import/Export Annotations onExportAnnotationCommand This function is called if a change has been made to annotations in the current document. Unlike onAnnotationChanged, this function has an XFDF command string as its parameter. If you are modifying or deleting multiple annotations, then on Android the function is only called once, and on iOS it is called for each annotation. Known Issues On iOS, there is currently a bug that prevents the last XFDF from being retrieved when modifying annotations while collaboration mode is enabled. Type: function Optional. Source: DocumentView.js line 886 Parameters: Name Type Description action string the action that occurred (add, delete, modify) xfdfCommand string an xfdf string containing info about the edit annotations array an array of annotation data. When collaboration is enabled data comes in the format {id: string}, otherwise the format is {id: string, pageNumber: number, type: string}. In both cases, the data represents the annotations that have been changed. type is one of the Config.Tools constants. Example &lt;DocumentView onExportAnnotationCommand = {({action, xfdfCommand, annotations}) =&gt; { console.log('Annotation edit action is', action); console.log('The exported xfdfCommand is', xfdfCommand); annotations.forEach((annotation) =&gt; { console.log('Annotation id is', annotation.id); if (!this.state.collabEnabled) { console.log('Annotation pageNumber is', annotation.pageNumber); console.log('Annotation type is', annotation.type); } }); }} collabEnabled={this.state.collabEnabled} currentUser={'Pdftron'} /&gt; Layout onLayoutChanged This function is called when the layout of the viewer has been changed. Type: function Optional. Source: DocumentView.js line 707 Example &lt;DocumentView onLayoutChanged = {() =&gt; { console.log('Layout has been updated.'); }} /&gt; Long Press Menu onLongPressMenuPress This function is called if the pressed long press menu item is passed in to overrideLongPressMenuBehavior. Type: function Optional. Source: DocumentView.js line 345 Parameters: Name Type Description longPressMenu Config.LongPressMenu the menu item that has been pressed. longPressText string the selected text if pressed on text, empty otherwise Example &lt;DocumentView onLongPressMenuPress = {({longPressMenu, longPressText}) =&gt; { console.log('Long press menu item', longPressMenu, 'has been pressed'); if (longPressText !== '') { console.log('The selected text is', longPressText); } }} /&gt; Multi-tab onTabChanged The function is activated when a tab is changed. This API is meant for tab-specific changes. If you would like to know when the document finishes loading instead, see the onDocumentLoaded event. Type: function Optional. Source: DocumentView.js line 1654 Parameters: Name Type Description currentTab string The file path of current tab's document Example &lt;DocumentView multiTabEnabled={true} onTabChanged={({currentTab}) =&gt; { console.log(\"The current tab is \", currentTab); }} /&gt; Open a Document onDocumentLoaded This function is called when the document finishes loading. Type: function Optional. Source: DocumentView.js line 173 Parameters: Name Type path string Example &lt;DocumentView onDocumentLoaded = {(path) =&gt; { console.log('The document has finished loading:', path); }} /&gt; onDocumentError This function is called when document opening encounters an error. Type: function Optional. Source: DocumentView.js line 189 Parameters: Name Type error string Example &lt;DocumentView onDocumentError = {(error) =&gt; { console.log('Error occured during document opening:', error); }} /&gt; Page onPageChanged This function is called when the page number has been changed. Type: function Optional. Source: DocumentView.js line 206 Parameters: Name Type Description previousPageNumber int the previous page number pageNumber int the current page number Example &lt;DocumentView onPageChanged = {({previousPageNumber, pageNumber}) =&gt; { console.log('Page number changes from', previousPageNumber, 'to', pageNumber); }} /&gt; onPageMoved This function is called when a page has been moved in the document. Type: function Optional. Source: DocumentView.js line 1633 Parameters: Name Type Description previousPageNumber int the previous page number pageNumber int the current page number Example &lt;DocumentView onPageMoved = {({previousPageNumber, pageNumber}) =&gt; { console.log('Page moved from', previousPageNumber, 'to', pageNumber); }} /&gt; Scroll onScrollChanged This function is called when the scroll position has been changed. Type: function Optional. Source: DocumentView.js line 224 Parameters: Name Type Description horizontal number the horizontal position of the scroll vertical number the vertical position of the scroll Example &lt;DocumentView onScrollChanged = {({horizontal, vertical}) =&gt; { console.log('Current scroll position is', horizontal, 'horizontally, and', vertical, 'vertically.'); }} /&gt; Text Selection onTextSearchStart This function is called immediately before a text search begins, either through user actions, or function calls such as findText. Type: function Optional. Source: DocumentView.js line 1219 Example &lt;DocumentView onTextSearchStart = {() =&gt; { console.log('Text search has started'); }} /&gt; onTextSearchResult This function is called after a text search is finished or canceled. Type: function Optional. Source: DocumentView.js line 1257 Parameters: Name Type Description found boolean whether a result is found. If false, it could be caused by not finding a matching result in the document, invalid text input, or action cancellation (user actions or cancelFindText) textSelection object the text selection, in the format {html: string, unicode: string, pageNumber: number, quads: [[{x: number, y: number}, {x: number, y: number}, {x: number, y: number}, {x: number, y: number}], ...]}. If no such selection could be found, this would be null Quads indicate the quad boundary boxes for the selection, which could have a size larger than 1 if selection spans across different lines. Each quad have 4 points with x, y coordinates specified in number, representing a boundary box. The 4 points are in counter-clockwise order, though the first point is not guaranteed to be on lower-left relatively to the box. Example &lt;DocumentView onTextSearchResult = {({found, textSelection}) =&gt; { if (found) { console.log('Found selection on page', textSelection.pageNumber); for (let i = 0; i &lt; textSelection.quads.length; i ++) { const quad = textSelection.quads[i]; console.log('selection boundary quad', i); for (const quadPoint of quad) { console.log('A quad point has coordinates', quadPoint.x, quadPoint.y); } } } }} /&gt; UI Customization onLeadingNavButtonPressed This function is called when the leading navigation button is pressed. Type: function Optional. Source: DocumentView.js line 157 Example &lt;DocumentView onLeadingNavButtonPressed = {() =&gt; { console.log('The leading nav has been pressed'); }} /&gt; onToolChanged This function is called when the current tool changes to a new tool Type: function Optional. Source: DocumentView.js line 1179 Parameters: Name Type Description previousTool Config.Tools | string the previous tool (one of the Config.Tools constants or \"unknown tool\"), representing the tool before change tool Config.Tools | string the current tool (one of the Config.Tools constants or \"unknown tool\"), representing the current tool Example &lt;DocumentView onToolChanged = {({previousTool, tool}) =&gt; { console.log('Tool has been changed from', previousTool, 'to', tool); }} /&gt; Undo/Redo onUndoRedoStateChanged This function is called when the state of the current document's undo/redo stack has been changed. Type: function Optional. Source: DocumentView.js line 1430 Example &lt;DocumentView onUndoRedoStateChanged = {() =&gt; { console.log(\"Undo/redo stack state changed\"); }} /&gt; Zoom onZoomChanged This function is called when the zoom scale has been changed. Type: function Optional. Source: DocumentView.js line 240 Parameters: Name Type Description zoom double the current zoom ratio of the document Example &lt;DocumentView onZoomChanged = {(zoom) =&gt; { console.log('Current zoom ratio is', zoom); }} /&gt; onZoomFinished This function is called when a zooming has been finished. For example, if zoom via gesture, this is called on gesture release. Type: function Optional. Source: DocumentView.js line 257 Parameters: Name Type Description zoom double the current zoom ratio of the document Example &lt;DocumentView onZoomFinished = {(zoom) =&gt; { console.log('Current zoom ratio is', zoom); }} /&gt;  Search results Close Documentation generated by JSDoc 3.6.7 on 2021-10-04T11:23:33-07:00 using the DocStrap template. "},"Config.html":{"id":"Config.html","title":"Class: Config","body":" PDFTron React Native Classes ConfigDocumentViewPDFViewCtrlRNPdftron Events onAnnotationMenuPressonAnnotationsSelectedonAnnotationChangedonFormFieldValueChangedonBookmarkChangedonBehaviorActivatedonExportAnnotationCommandonLayoutChangedonLongPressMenuPressonTabChangedonDocumentLoadedonDocumentErroronPageChangedonPageMovedonScrollChangedonTextSearchStartonTextSearchResultonLeadingNavButtonPressedonToolChangedonUndoRedoStateChangedonZoomChangedonZoomFinished Config Defines configuration constants for the viewer. See Config.ts for the full list of constants. Due to the length of the source file, we have included links to the exact lines of the source code where these APIs have been implemented. Source: Config.js line 1 Members Buttons Buttons define the various kinds of buttons for the viewer Source: Config.js line 18 Constants: editToolButton viewControlsButton freeHandToolButton highlightToolButton underlineToolButton squigglyToolButton strikeoutToolButton rectangleToolButton ellipseToolButton lineToolButton arrowToolButton polylineToolButton polygonToolButton cloudToolButton signatureToolButton freeTextToolButton stickyToolButton calloutToolButton stampToolButton toolsButton searchButton shareButton editPagesButton viewLayersButton printButton closeButton saveCopyButton saveIdenticalCopyButton saveFlattenedCopyButton formToolsButton fillSignToolsButton moreItemsButton digitalSignatureButton thumbnailsButton listsButton thumbnailSlider outlineListButton annotationListButton userBookmarkListButton reflowButton editMenuButton cropPageButton undo redo addPageButton saveReducedCopyButton saveCroppedCopyButton savePasswordCopyButton Tools Tools define the various kinds of tools for the viewer Source: Config.js line 73 Constants: annotationEdit textSelect pan annotationEraserTool annotationCreateSticky annotationCreateFreeHand annotationCreateTextHighlight annotationCreateTextUnderline annotationCreateTextSquiggly annotationCreateTextStrikeout annotationCreateFreeText annotationCreateCallout annotationCreateSignature annotationCreateLine annotationCreateArrow annotationCreatePolyline annotationCreateStamp annotationCreateRubberStamp annotationCreateRectangle annotationCreateEllipse annotationCreatePolygon annotationCreatePolygonCloud annotationCreateDistanceMeasurement annotationCreatePerimeterMeasurement annotationCreateAreaMeasurement annotationCreateFileAttachment annotationCreateSound annotationCreateRedaction annotationCreateLink annotationCreateRedactionText annotationCreateLinkText annotationCreateFreeHighlighter formCreateTextField formCreateCheckboxField formCreateSignatureField formCreateRadioField formCreateComboBoxField formCreateListBoxField pencilKitDrawing FitMode FitMode define how a page should fit relative to the viewer, alternatively, the default zoom level Source: Config.js line 120 Constants: FitPage FitWidth FitHeight Zoom LayoutMode LayoutMode defines the layout mode of the viewer Source: Config.js line 130 Constants: Single Continuous Facing FacingContinuous FacingCover FacingCoverContinuous FieldFlags FieldFlags define the property flags for a form field Source: Config.js line 142 Constants: ReadOnly Required AnnotationMenu AnnotationMenu defines the menu items when an annotation is selected Source: Config.js line 150 Constants: style note copy duplicate delete flatten editText editInk search share markupType read screenCapture playSound openAttachment calibrate EraserType EraserType defines the type of eraser that will be used when eraser is selected Source: Config.js line 172 Constants: annotationEraser hybrideEraser inkEraser LongPressMenu LongPressMenu defines the menu items when a long press on empty space or text occurs Source: Config.js line 181 Constants: copy paste search share read Actions Actions define potentially overridable action to the viewer Source: Config.js line 192 Constants: linkPress stickyNoteShowPopUp AnnotationFlags AnnotationFlags define the flags for any annotation in the document Source: Config.js line 200 Constants: hidden invisible locked lockedContents noRotate noView noZoom print readOnly toggleNoView DefaultToolbars DefaultToolbars define a set of pre-designed toolbars for easier customization Source: Config.js line 216 Constants: View Annotate Draw Insert FillAndSign PrepareForm Measure Pens Redaction Favorite ToolbarIcons ToolbarIcons define default toolbar icons for use for potential custom toolbars Source: Config.js line 232 Constants: View Annotate Draw Insert FillAndSign PrepareForm Measure Pens Redaction Favorite CustomToolbarKey CustomToolbarKey defines the necessary keys for a custom toolbar Source: Config.js line 248 Constants: Id Name Icon Items ThumbnailFilterMode ThumbnailFilterMode defines filter modes in the thumbnails browser Source: Config.js line 258 Constants: Annotated Bookmarked Conversion Conversion defines conversion sources and destinations Source: Config.js line 266 Constants: Screen Canvas Page ViewModePickerItem ViewModePickerItem defines view mode items in the view mode dialog Source: Config.js line 275 Constants: Crop Rotation ColorMode ZoomLimitMode ZoomLimitMode defines the limit mode for zoom in the current document viewer Source: Config.js line 284 Constants: None Absolute Relative OverprintMode OverprintMode defines when overprint would be applied in the viewer Source: Config.js line 293 Constants: On Off OnlyPDFX ColorPostProcessMode ColorPostProcessMode defines color modifications after rendering in the viewer Source: Config.js line 302 Constants: None Invert GradientMap NightMode ReflowOrientation ReflowOrientation defines the scrolling direction when in reflow viewing mode Source: Config.js line 312 Constants: Horizontal Vertical ExportFormat Export to format Source: Config.js line 320 Constants: BMP JPEG PNG  Search results Close Documentation generated by JSDoc 3.6.7 on 2021-10-04T11:23:33-07:00 using the DocStrap template. "},"PDFViewCtrl.html":{"id":"PDFViewCtrl.html","title":"Class: PDFViewCtrl","body":" PDFTron React Native Classes ConfigDocumentViewPDFViewCtrlRNPdftron Events onAnnotationMenuPressonAnnotationsSelectedonAnnotationChangedonFormFieldValueChangedonBookmarkChangedonBehaviorActivatedonExportAnnotationCommandonLayoutChangedonLongPressMenuPressonTabChangedonDocumentLoadedonDocumentErroronPageChangedonPageMovedonScrollChangedonTextSearchStartonTextSearchResultonLeadingNavButtonPressedonToolChangedonUndoRedoStateChangedonZoomChangedonZoomFinished PDFViewCtrl A React component for displaying documents of different types such as PDF, docx, pptx, xlsx and various image formats. PDFViewCtrl is useful when a higher level of customization is required. For easy all-in-one document viewing and editing, use DocumentView. Members document The path or url to the document. Required. Type: string Example &lt;PDFViewCtrl document={'https://pdftron.s3.amazonaws.com/downloads/pl/PDFTRON_about.pdf'} /&gt;  Search results Close Documentation generated by JSDoc 3.6.7 on 2021-10-04T11:23:33-07:00 using the DocStrap template. "},"RNPdftron.html":{"id":"RNPdftron.html","title":"Interface: RNPdftron","body":" PDFTron React Native Classes ConfigDocumentViewPDFViewCtrlRNPdftron Events onAnnotationMenuPressonAnnotationsSelectedonAnnotationChangedonFormFieldValueChangedonBookmarkChangedonBehaviorActivatedonExportAnnotationCommandonLayoutChangedonLongPressMenuPressonTabChangedonDocumentLoadedonDocumentErroronPageChangedonPageMovedonScrollChangedonTextSearchStartonTextSearchResultonLeadingNavButtonPressedonToolChangedonUndoRedoStateChangedonZoomChangedonZoomFinished RNPdftron RNPdftron contains static methods for global library initialization, configuration, and utility methods. Methods initialize Initializes PDFTron SDK with your PDFTron commercial license key. You can run PDFTron in demo mode by passing an empty string. Parameters: Name Type Description licenseKey string your PDFTron license key Example RNPdftron.initialize('your_license_key'); enableJavaScript Enables JavaScript engine for PDFTron SDK, by default it is enabled. Parameters: Name Type Description enabled boolean whether to enable or disable JavaScript engine Example RNPdftron.enableJavaScript(true); getVersion Gets the current PDFNet version. Returns: Name Type Description version Promise&lt;string&gt; current PDFNet version Example RNPdftron.getVersion().then((version) =&gt; { console.log(\"Current PDFNet version:\", version); }); getPlatformVersion Gets the version of current platform (Android/iOS). Returns: Name Type Description platformVersion Promise&lt;string&gt; current platform version (Android/iOS) Example RNPdftron.getPlatformVersion().then((platformVersion) =&gt; { console.log(\"App currently running on:\", platformVersion); }); getSystemFontList Gets the font list available on the OS (Android only). This is typically useful when you are mostly working with non-ascii characters in the viewer. Returns: Name Type Description fontList Promise&lt;string&gt; the font list available on Android Example RNPdftron.getSystemFontList().then((fontList) =&gt; { console.log(\"OS font list:\", fontList); }); clearRubberStampCache Clear the information and bitmap cache for rubber stamps (Android only). This is typically useful when the content of rubber stamps has been changed in the viewer. Returns: Type Promise&lt;void&gt; Example RNPdftron.clearRubberStampCache().then(() =&gt; { console.log(\"Rubber stamp cache cleared\"); }); encryptDocument Encrypts (password-protect) a document (must be a PDF). Note: This function does not lock the document, it cannot be used while the document is opened in the viewer. Parameters: Name Type Description filePath string the local file path to the file password string the password you would like to set currentPassword string the current password, use empty string if no password Returns: Type Promise&lt;void&gt; Example RNPdftron.encryptDocument(\"/sdcard/Download/new.pdf\", \"1111\", \"\").then(() =&gt; { console.log(\"done password\"); }); pdfFromOfficeTemplate Generates a PDF using a template in the form of an Office document and replacement data in the form of a JSON object. For more information please see our template guide. The user is responsible for cleaning up the temporary file that is generated. Parameters: Name Type Description docxPath string the local file path to the template file json object the replacement data in the form of a JSON object Returns: Name Type Description resultPdfPath Promise&lt;string&gt; the local file path to the generated PDF Example RNPdftron.pdfFromOfficeTemplate(\"/sdcard/Download/red.docx\", json).then((resultPdfPath) =&gt; { console.log(resultPdfPath); }); exportAsImage Export a PDF page to an image format defined in Config.ExportFormat. Unlike DocumentView.exportAsImage, this method is static and should only be called before a DocumentView instance has been created or else unexpected behaviour can occur. This method also takes a local file path to the desired PDF. Parameters: Name Type Description pageNumber int the page to be converted; if the value does not refer to a valid page number, the file path will be undefined dpi double the output image resolution exportFormat Config.ExportFormat image format to be exported to filePath string local file path to pdf Returns: Name Type Description resultImagePath Promise&lt;string&gt; the temp path of the created image, user is responsible for clean up the cache Example RNPdftron.exportAsImage(1, 92, Config.ExportFormat.BMP, \"/sdcard/Download/red.pdf\").then( (resultImagePath) =&gt; { console.log('export', resultImagePath); });  Search results Close Documentation generated by JSDoc 3.6.7 on 2021-10-04T11:23:33-07:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
